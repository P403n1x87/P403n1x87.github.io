<!DOCTYPE html>
<html>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>

  
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Prime Numbers, Algorithms and Computer Architectures</title>
  <meta name="description" content="What does the principle of locality of reference have to do with prime numbers? This is what we will discover in this post. We will use the segmented version...">
  <meta name="theme-color" content="#100808" />

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://p403n1x87.github.io//number%20theory/algorithms/architecture/2017/03/06/primes.html">
  <link rel="alternate" type="application/rss+xml" title="The Hub of Heliopolis" href="https://p403n1x87.github.io//feed.xml">
</head>


  <body>

    <header class="site-header">
  <div class="site-title">
    ~# <a href="/">the-<strong>hub</strong>-of-heliopolis</a><span class="blinking-cursor">&block;</span>
  </div>
  <div class="wrapper">
    <nav class="site-nav">
      <div class="trigger">
        
          
        
          
          <a class="page-link" href="/">Posts</a>
          
        
          
        
          
          <a class="page-link" href="/about/">About</a>
          
        
      </div>
    </nav>

  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <h1 class="post-title" itemprop="name headline">Prime Numbers, Algorithms and Computer Architectures</h1>

<article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="sidepane post-header">
    
    <div class="post-info">
  <div class="post-detail"><i class="fa fa-calendar-plus-o" aria-hidden="true"></i>&nbsp;2017 Mar 6</div>
  <div class="post-detail"><i class="fa fa-clock-o" aria-hidden="true"></i>&nbsp;<span class="reading-time" title="Estimated read time">
  
  
    a 14 minute read
  
</span>
</div>
  <div class="flex-container flex-row post-detail">
  <div><i class="fa fa-archive" aria-hidden="true"></i></div>&nbsp;
  <div><span class="category">Number Theory</span><span class="category">Algorithms</span><span class="category">Architecture</span></div>
</div>
<div class="flex-container flex-row post-detail">
  <div><i class="fa fa-tags" aria-hidden="true"></i></div>&nbsp;
  <div class="flex-container flex-row flex-wrap"><span class="tag">Programming</span><span class="tag">C++</span><span class="tag">Prime Numbers</span><span class="tag">Algorithms</span></div>
</div>

  
</div>


    <div class="toc">
      <div class="heading">Table of Contents</div>
      <ul class="section-nav">
<li class="toc-entry toc-h1"><a href="#counting-primes">Counting Primes</a></li>
<li class="toc-entry toc-h1"><a href="#segmented-sieve">Segmented Sieve</a></li>
</ul>
    </div>

  </header>

  <div class="post-text">

    <div class="post-excerpt">
      <p>What does the principle of locality of reference have to do with prime numbers? This is what we will discover in this post. We will use the segmented version of the Sieve of Eratosthenes to see how hardware specifications can (read <em>should</em>) be used to fix design parameters for our routines.</p>

    </div>

    <div class="post-content" itemprop="articleBody">
      <p>A natural number $p\in\mathbb N$ is said to be <em>prime</em> if its only divisors are 1 and $p$ itself. Any other number that does not have this property is sometimes called <em>composite</em>. The discovery that there are infinitely many prime numbers dates back to c. 300 BC and is due to Euclid. His argument by contradiction is very simple: suppose that, indeed, there are only finitely many primes, say $p_1,\ldots,p_n$. The natural number</p>

<script type="math/tex; mode=display">m=p_1p_2\cdots p_n + 1</script>

<p>is larger than and evidently not divisible by any of the primes by construction, and therefore $m$ must be prime. However, being larger than any of the $p_k$s, $m$ cannot be one of the finitely many primes, thus reaching to a contradiction.</p>

<p>Prime numbers play a fundamental role in <em>Number Theory</em>, a branch of Mathematics that deals with the properties of the natural numbers. Everybody gets to know about the prime factorisation of the natural numbers, a result so important that has been given the name of <em>Fundamental Theorem of Arithmetic</em>.</p>

<h1 id="counting-primes">
<a id="counting-primes" class="anchor" href="#counting-primes" aria-hidden="true"><span class="octicon octicon-link"></span></a>Counting Primes</h1>

<p>Even though we saw that prime numbers are infinite, one might still want to know how many prime numbers are there within a certain upper bound. As numbers become bigger, the help of a calculator becomes crucial to tackle this problem and therefore it makes sense to think of algorithms that would get us to the answer efficiently.</p>

<p>The fastest way to count all the primes less than a given upper bound $n$ is by means of an ancient algorithm known as the <em>Sieve of Eratosthenes</em>. The idea is to start with the sequence of all the numbers from 0 up to $n$ and discard/mark the composite numbers as they are discovered. By definition, 0 and 1 are not prime, so they are removed. The number 2 is prime, but all its multiples are not, so we proceed by removing all the multiples of 2. We keep the first number that remains after 2, 3 in this case, and proceed to remove its multiples (starting from its square, since smaller multiples have already been removed at the previous steps). The process is repeated until it is no longer possible to proceed beyond the assigned bound $n$. It is clear that it is enough to get up to at most $\lceil\sqrt n\rceil$.</p>

<p>The following is a simple implementation in C++.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;cassert&gt;
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Sieve</span> <span class="p">{</span>

<span class="k">private</span><span class="o">:</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="o">*</span> <span class="n">sieve</span><span class="p">;</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>  <span class="o">*</span> <span class="n">primes</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
  <span class="n">Sieve</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="o">:</span> <span class="n">primes</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sieve</span> <span class="o">=</span> <span class="k">new</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

    <span class="p">(</span><span class="o">*</span><span class="n">sieve</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">(</span><span class="o">*</span><span class="n">sieve</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ceil</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">));</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
      <span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">sieve</span><span class="p">)[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">sieve</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span> <span class="n">j</span> <span class="o">+=</span> <span class="n">i</span><span class="p">)</span>
          <span class="p">(</span><span class="o">*</span><span class="n">sieve</span><span class="p">)[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="o">~</span><span class="n">Sieve</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">delete</span> <span class="n">sieve</span> <span class="p">;</span>
    <span class="k">delete</span> <span class="n">primes</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">*</span> <span class="n">get_primes</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">primes</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">primes</span> <span class="o">=</span> <span class="k">new</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span>

      <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sieve</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">sieve</span><span class="p">)[</span><span class="n">i</span><span class="p">])</span> <span class="n">primes</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">primes</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">int</span> <span class="n">get</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">());</span>
    <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">primes</span><span class="p">)[</span><span class="n">i</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="kt">int</span> <span class="n">count</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">primes</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="n">get_primes</span><span class="p">();</span>

    <span class="k">return</span> <span class="n">primes</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>

  <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>

  <span class="n">Sieve</span> <span class="n">s</span> <span class="o">=</span> <span class="n">Sieve</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"There are "</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" primes between 0 and "</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

  <span class="cp">#ifdef VERBOSE
</span>  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">count</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="cp">#endif
</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<blockquote>
  <p>A vector of booleans is implemented in C++ by an arry of bits instead of single bytes. Apart from turning all the possible complier optimisations, at the hardware level, this more compact data structure is more cache-friendly. Here is a first link between a software implementation of a prime search and the computer architecture the code runs on.</p>
</blockquote>

<p>With an input of the order of $10^6$ the sieve is still quite fast. However the memory requirements are substantial: up to $10^9$ we are able to still use integers, but the memory consumption is of the order of the GB. The amount of memory on the system then can pose a serious limitation to the input parameter.</p>

<h1 id="segmented-sieve">
<a id="segmented-sieve" class="anchor" href="#segmented-sieve" aria-hidden="true"><span class="octicon octicon-link"></span></a>Segmented Sieve</h1>

<p>If we want to list and/or count all the primes between two given (and possibly quite large) integers, we need a <em>Segmented Sieve</em>. If we are interested in all the primes between $a$ and $b$ we could, in principle, use the sieve of Eratosthenes to find all the primes up to $b$ and then list/count all the primes larger than $a$. But with $b$ of the order, say, $10^{15}$, a lot of memory is required to hold the result. Instead we can split the interval $[a,b]$ into chunks and process them separately.</p>

<p>The two main questions that we need to answer are: how do we adapt the sieve algorithm to start from $a$ rather than 0, and how do we fix the chunk size. Let us deal with the latter question first. The reason why we need a segmented sieve in the first place is because of memory limitations. So an upper bound for the chunck size is given by the available memory. However, for large values of the inputs, the sieve might need to jump to memory location which are further apart. But how do we quantify this “further apart”? The answer, again, is in the system architecture, which quite likely include a system of cache memory. In order not to violate the locality principle we should choose a chunk size which is comparable to the cache size. Assuming this to be of the order of the MB, and recalling that <code class="highlighter-rouge">vector&lt;bool&gt;</code> is an array of bits, a possible chunk size is of the order of $10^7$.</p>

<p>Coming to the question of how to implemente a segmented sieve, all we need to do is mark/remove all the composite number in range. Of course we would need to start by removing all the even numbers, then all the multiples of 3, then of 5 and so on. Therefore we still need the knowledge of the primes starting from 2 and going above. But how much above? Since our upper limit is $b$, we need all the prime numbers up to $\lceil\sqrt b\rceil$, which can be obtained with the standard sieve discussed earlier. These prime numbers can then be used to discover all the primes in the range $[a,b]$. We start by removing the first even number greater than or equal to $a$, together with all the numbers obtained by repeatedly adding 2 to it until we are out of bound. More generally, to find the first multiple of the prime $p$ in $[a,b]$ we use the formula</p>

<script type="math/tex; mode=display">s = \left\lceil\frac ap\right\rceil\cdot p</script>

<p>However, recall that, for the standard sieve we really have to start from $p^2$, since lower multiples of $p$ have already been removed at the previous iteration. Therefore, as our starting point we pick the <em>maximum</em> between $s$ and $p^2$ (actually between $\lceil a/p\rceil$ and $p$).</p>

<p>The following is a simple implementation of the Segmented Sieve in C++.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#define CHUNK 10000000 // 10e7
</span>
<span class="k">class</span> <span class="nc">SSieve</span> <span class="p">{</span>

<span class="k">private</span><span class="o">:</span>
  <span class="n">Sieve</span>        <span class="o">*</span> <span class="n">sieve</span><span class="p">;</span>   <span class="c1">// Sieve</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="o">*</span> <span class="n">ssieve</span><span class="p">;</span>  <span class="c1">// Segmented Sieve</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>  <span class="o">*</span> <span class="n">seg_c</span><span class="p">;</span>   <span class="c1">// primes in each segment</span>
  <span class="kt">long</span> <span class="kt">long</span>      <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>    <span class="c1">// Bounds</span>
  <span class="kt">int</span>            <span class="n">c</span><span class="p">;</span>       <span class="c1">// Cached primes count</span>
  <span class="kt">int</span>            <span class="n">seg</span><span class="p">;</span>     <span class="c1">// Current segment</span>
  <span class="kt">long</span> <span class="kt">long</span>      <span class="n">size</span><span class="p">;</span>    <span class="c1">// Total numbers in interval</span>
  <span class="kt">int</span>            <span class="n">max_seg</span><span class="p">;</span> <span class="c1">// Total number of segments</span>

  <span class="kt">void</span> <span class="nf">do_segment</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">seg</span> <span class="o">==</span> <span class="n">s</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span> <span class="c1">// Do not regenerate the current segment</span>

    <span class="n">assert</span><span class="p">(</span><span class="n">s</span> <span class="o">&lt;</span> <span class="n">max_seg</span><span class="p">);</span>

    <span class="n">seg</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>

    <span class="c1">// Determine segment bounds</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">s</span> <span class="o">*</span> <span class="n">CHUNK</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="n">l</span> <span class="o">+</span> <span class="n">min</span><span class="p">(</span><span class="n">CHUNK</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">size</span> <span class="o">-</span> <span class="n">s</span> <span class="o">*</span> <span class="n">CHUNK</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

    <span class="c1">// Allocate the new segmented sieve</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ssieve</span><span class="p">)</span> <span class="k">delete</span> <span class="n">ssieve</span><span class="p">;</span>
    <span class="n">ssieve</span> <span class="o">=</span> <span class="k">new</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">h</span> <span class="o">-</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

    <span class="c1">// Remove composite numbers in segment</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">p</span> <span class="o">:</span> <span class="p">(</span><span class="o">*</span><span class="n">sieve</span><span class="o">-&gt;</span><span class="n">get_primes</span><span class="p">()))</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="n">h</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">max</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">l</span><span class="o">/</span><span class="n">p</span> <span class="o">+</span> <span class="p">(</span><span class="n">l</span> <span class="o">%</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">),</span> <span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="n">p</span> <span class="o">-</span> <span class="n">l</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ssieve</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">p</span><span class="p">)</span> <span class="c1">//{</span>
        <span class="p">(</span><span class="o">*</span><span class="n">ssieve</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

<span class="k">public</span><span class="o">:</span>
  <span class="n">SSieve</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">low</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">high</span><span class="p">)</span> <span class="o">:</span> <span class="n">c</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">ssieve</span><span class="p">(</span><span class="nb">NULL</span><span class="p">),</span> <span class="n">seg</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">seg_c</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">low</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="p">);</span>

    <span class="n">seg_c</span>   <span class="o">=</span> <span class="k">new</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">high</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">low</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="n">low</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

    <span class="n">a</span>       <span class="o">=</span> <span class="n">low</span><span class="p">;</span>
    <span class="n">b</span>       <span class="o">=</span> <span class="n">high</span><span class="p">;</span>
    <span class="n">size</span>    <span class="o">=</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">sieve</span>   <span class="o">=</span> <span class="k">new</span> <span class="n">Sieve</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">b</span><span class="p">)));</span> <span class="c1">// The standard sieve</span>
    <span class="n">max_seg</span> <span class="o">=</span> <span class="n">size</span> <span class="o">/</span> <span class="n">CHUNK</span> <span class="o">+</span> <span class="p">(</span><span class="n">size</span> <span class="o">%</span> <span class="n">CHUNK</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="o">~</span><span class="n">SSieve</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">delete</span> <span class="n">sieve</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">ssieve</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">seg_c</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max_seg</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">do_segment</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">bool</span> <span class="n">p</span> <span class="o">:</span> <span class="p">(</span><span class="o">*</span><span class="n">ssieve</span><span class="p">))</span> <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="n">c</span><span class="o">++</span><span class="p">;</span>
        <span class="c1">// Keep track of the number of primes in segments</span>
        <span class="c1">// This is used by SSieve::get to retrieve the primes</span>
        <span class="n">seg_c</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">long</span> <span class="kt">long</span> <span class="n">get</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">());</span>

    <span class="kt">int</span> <span class="n">s</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// Determine which segment the requested prime belongs to</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="n">seg_c</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">s</span><span class="o">++</span><span class="p">)</span>
      <span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">seg_c</span><span class="p">)[</span><span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>

    <span class="c1">// Reconstruct the segmented sieve if necessary</span>
    <span class="n">do_segment</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

    <span class="c1">// Translate into the actual prime</span>
    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="p">(</span><span class="o">*</span><span class="n">seg_c</span><span class="p">)[</span><span class="n">s</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">ssieve</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">ssieve</span><span class="p">)[</span><span class="n">k</span><span class="p">])</span> <span class="n">n</span><span class="o">++</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">j</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">k</span> <span class="o">+</span> <span class="n">s</span> <span class="o">*</span> <span class="n">CHUNK</span> <span class="o">+</span> <span class="n">a</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span></code></pre></figure>

<p>This can be tested with a slightly modified <code class="highlighter-rouge">main</code> procedure, for example</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">long</span> <span class="kt">long</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>

  <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>

  <span class="n">SSieve</span> <span class="n">ss</span> <span class="o">=</span> <span class="n">SSieve</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>

  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"There are "</span> <span class="o">&lt;&lt;</span> <span class="n">ss</span><span class="p">.</span><span class="n">count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" primes between "</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="s">" and "</span> <span class="o">&lt;&lt;</span> <span class="n">m</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

  <span class="cp">#ifdef VERBOSE
</span>  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ss</span><span class="p">.</span><span class="n">count</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ss</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="cp">#endif
</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>


    </div>

    <div class="comments">
  <h1>Comments</h1>

  
    
    
    <ul class="comment-list">
      
        
        
      
    </ul>
  

  <h2 id="comment-hdr">Leave a comment</h2>
  <script src="https://p403n1x87.github.io//js/comments.js"></script>

<form id     = "post-comment"
      class  = "comment"
      method = "post"
      action = "">

  <input type        = "text"
         name        = "fields[name]"
         id          = "name"
         placeholder = "Name"/>

  <input type        = "text"
         name        = "fields[email]"
         placeholder = "E-mail address (optional; stored hashed for privacy)"/>

  <textarea name        = "fields[comment]"
            id          = "comment"
            rows        = "5"
            placeholder = "Write your comment here. You can use markdown and LaTeX (use $...$ to inline)"></textarea>

  <button type  = "button"
          class = "flat_button"
          id    = "btn-submit-comment"
          onClick="submitComment();">
    SUBMIT FOR APPROVAL
  </button>


  <!-- Hidden fields -->

   <input type  = "hidden"
          name  = "fields[pic]"
          value = "primes"/>

    <input type  = "hidden"
           id    = "timestamp"
           name  = "fields[timestamp]"
           value = "1557091936"/>

    <input type  = "hidden"
           id    = "parent"
           name  = "fields[parent]"
           value = "0"/>

</form>

<div id="snackbar"></div>


</div>

  </div>
</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The Hub of Heliopolis</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>The Hub of Heliopolis is maintained by Gabriele N. Tornetta</li>
          <li><a href="mailto:phoenix1987@gmail.com">phoenix1987@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <i class="fa fa-github" aria-hidden="true"></i>&nbsp;<a href="https://github.com/P403n1x87"><span class="username">P403n1x87</span></a>

          </li>
          

          

          <li>
            <i class="fa fa-rss-square" aria-hidden="true"></i>&nbsp;<a href="/feed.xml">Subscribe</a>
          </li>
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The Hub of Heliopolis is the <i>tech bay</i> of <a href="http://thenestofheliopolis.blogspot.co.uk/">The Nest of Heliopolis</a>. It is the home of all my <i>encounters</i> with technology that I consider worth sharing with the World.
</p>
      </div>
    </div>

    <div class="footer-copyright">
      Copyright (C) 2017 Gabriele N. Tornetta. All rights reserved.
    </div>

  </div>

</footer>


    
      <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-104560783-1', 'auto');
  ga('send', 'pageview');

</script>

    

    <script src="https://use.fontawesome.com/8c7b940d60.js"></script>

    <!-- MathJax support -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>


  </body>

</html>
