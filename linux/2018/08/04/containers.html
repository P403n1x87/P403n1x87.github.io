<!DOCTYPE html>
<html>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>

  
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>What Actually Are Containers?</title>
  <meta name="description" content="Containers are the big thing of the moment. It is quite common to find blog posts and articles that explain what containers are _not_:  "containers are not v...">
  <meta name="theme-color" content="#100808" />

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://p403n1x87.github.io//linux/2018/08/04/containers.html">
  <link rel="alternate" type="application/rss+xml" title="The Hub of Heliopolis" href="https://p403n1x87.github.io//feed.xml">
</head>


  <body>

    <header class="site-header">
  <div class="site-title">
    ~# <a href="/">the-<strong>hub</strong>-of-heliopolis</a><span class="blinking-cursor">&block;</span>
  </div>
  <div class="wrapper">
    <nav class="site-nav">
      <div class="trigger">
        
          
        
          
          <a class="page-link" href="/">Posts</a>
          
        
          
        
          
          <a class="page-link" href="/about/">About</a>
          
        
      </div>
    </nav>

  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <h1 class="post-title" itemprop="name headline">What Actually Are Containers?</h1>

<article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="sidepane post-header">
    
    <div class="post-info">
  <div class="post-detail"><i class="fa fa-calendar-plus-o" aria-hidden="true"></i>&nbsp;2018 Aug 4</div>
  <div class="post-detail"><i class="fa fa-clock-o" aria-hidden="true"></i>&nbsp;<span class="reading-time" title="Estimated read time">
  
  
    a 33 minute read
  
</span>
</div>
  <div class="flex-container flex-row post-detail">
  <div><i class="fa fa-archive" aria-hidden="true"></i></div>&nbsp;
  <div><span class="category">Linux</span></div>
</div>
<div class="flex-container flex-row post-detail">
  <div><i class="fa fa-tags" aria-hidden="true"></i></div>&nbsp;
  <div class="flex-container flex-row flex-wrap"><span class="tag">containers</span><span class="tag">jails</span></div>
</div>

  
    <div class="post-detail"><i class="fa fa-github" aria-hidden="true"></i>&nbsp;<a href="https://github.com/P403n1x87/asm/tree/master/chroot">P403n1x87/asm/chroot</a></div>
  
</div>


    <div class="toc">
      <div class="heading">Table of Contents</div>
      <ul class="section-nav">
<li class="toc-entry toc-h1"><a href="#introduction">Introduction</a>
<ul>
<li class="toc-entry toc-h2"><a href="#containers-defined">Containers Defined</a></li>
<li class="toc-entry toc-h2"><a href="#a-note-on-operating-systems">A Note on Operating Systems</a></li>
</ul>
</li>
<li class="toc-entry toc-h1"><a href="#creating-jails-with-chroot">Creating Jails With chroot</a>
<ul>
<li class="toc-entry toc-h2"><a href="#a-minimal-chroot-jail">A Minimal chroot Jail</a></li>
<li class="toc-entry toc-h2"><a href="#a-more-interesting-example">A More Interesting Example</a></li>
<li class="toc-entry toc-h2"><a href="#leaky-containers">Leaky Containers</a></li>
</ul>
</li>
<li class="toc-entry toc-h1"><a href="#control-groups">Control Groups</a>
<ul>
<li class="toc-entry toc-h2"><a href="#a-hierarchy-of-cgroups">A Hierarchy of cgroups</a></li>
<li class="toc-entry toc-h2"><a href="#how-to-work-with-control-groups">How to Work with Control Groups</a></li>
</ul>
</li>
<li class="toc-entry toc-h1"><a href="#linux-namespaces">Linux Namespaces</a>
<ul>
<li class="toc-entry toc-h2"><a href="#some-implementation-details">Some Implementation Details</a></li>
<li class="toc-entry toc-h2"><a href="#how-to-work-with-namespaces">How to Work with Namespaces</a></li>
</ul>
</li>
<li class="toc-entry toc-h1"><a href="#putting-it-all-together">Putting It All Together</a>
<ul>
<li class="toc-entry toc-h2"><a href="#process-containment-for-chroot-jails">Process Containment for chroot Jails</a></li>
<li class="toc-entry toc-h2"><a href="#wall-fortification">Wall Fortification</a></li>
</ul>
</li>
<li class="toc-entry toc-h1"><a href="#conclusions">Conclusions</a></li>
</ul>
    </div>

  </header>

  <div class="post-text">

    <div class="post-excerpt">
      <p>Containers are the big thing of the moment. It is quite common to find blog posts and articles that explain what containers are <em>not</em>:  “containers are not virtual machines”. Just what <em>are</em> they then? In this post we embark on a journey across some of the features of the Linux kernel to unveil the mystery.</p>

    </div>

    <div class="post-content" itemprop="articleBody">
      <h1 id="introduction">
<a id="introduction" class="anchor" href="#introduction" aria-hidden="true"><span class="octicon octicon-link"></span></a>Introduction</h1>

<p>When I first heard about containers, I turned to my favourite search engine to
find out more about them and what they are. Most of the resources I have read
through, though, seemed to put a great emphasis on what containers are <strong>not</strong>.
Containers are like virtual machines, but are <strong>not</strong> virtual machines.</p>

<p>So, what actually <strong>are</strong> they? After many unhelpful reads, the first good blog
post that I’ve come across and that explains what containers indeed are is <a href="https://jvns.ca/blog/2016/10/10/what-even-is-a-container/">What
even is a container</a>
by Julia Evans. If you go and read through that post (and I do recommended that
you do!), you will immediately learn that a container is like a cauldron where
you mix in the essential ingredients for a magic potion. Only in this case, the
ingredients are Linux kernel features.</p>

<p>If many posts on containers make it sounds like they are some sort of black
magic (how can you have a <em>lightweight</em> virtual machine?!), the aim of this post
is to show that the idea behind them is quite simple and made possible by a few
Linux kernel features, like <strong>control groups</strong>, <strong>chroot</strong> and <strong>namespaces</strong>. I
will discuss each of them in turn in this post, but you should also be aware
that there are other kernel features involved in containers to make them robust
and secure. These other aspects, however, will be part of a separate post. Here
we shall just focus on the essential ingredients that can allow you to literally
handcraft and run something that you may call a container, in the sense that is
commonly used these days.</p>

<h2 id="containers-defined">
<a id="containers-defined" class="anchor" href="#containers-defined" aria-hidden="true"><span class="octicon octicon-link"></span></a>Containers Defined</h2>

<p>Before we progress any further, I believe that we should take a moment to agree
on the meaning that we should attach to the word <em>container</em>. Much of the
confusion, in my opinion, arises from the many different definitions that are
out there. According to
<a href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization">Wikipedia</a>,
<em>containers</em> …</p>

<blockquote>
  <p>… may look like real computers from the point of view of programs running in
them. A computer program running on an ordinary operating system can see all
resources … of that computer. However, programs running inside a container
can only see the container’s contents and devices assigned to the container.</p>
</blockquote>

<p>My way of paraphrasing this definition is the following: a container is a main
process that runs in user-space that gives you the impression that you are
running an operating system with its own view of the file system, processes,
etc… on top of the operating system that is installed on the machine. In this
sense, a container <em>contains</em> part of the host resources and hosts its own
system and user applications.</p>

<h2 id="a-note-on-operating-systems">
<a id="a-note-on-operating-systems" class="anchor" href="#a-note-on-operating-systems" aria-hidden="true"><span class="octicon octicon-link"></span></a>A Note on Operating Systems</h2>

<p>Another cause of confusion, sometimes, is the definition of <em>operating system</em>
itself, so before moving on, I want to make sure we agree on this too. An
operating system can be thought as a <em>nut</em>. At its core we have, well, the
kernel, which is in direct control of the hardware. On its own, the kernel is a
<em>passive</em> component of an operating system. When an operating system is booted,
the kernel is the first part that gets loaded into memory and it quietly sits
there. Its purpose is to provide many “buttons and levers” (the <em>ABI</em>) that just
wait to be pushed and pulled to operate the hardware and provide services to
system and user applications. Around the kernel one usually finds, surprise
surprise, a shell. You might be familiar with Bash, Ksh, Zsh, etc… which allow
you to manipulate the file system (create, copy, move, delete files from disk),
launch applications etc … . Some of these applications are included with the
operating system and build on top of the kernel services to provide basic
functionalities (e.g. most if not all the standard Unix tools). Such
applications are known as <em>system application</em>. Other software, like text
editors, games, web browsers and alike are <em>user applications</em>. In some cases,
it is hard to decide between system and user applications, as the line between
them is not very clear and open to debate. However, once you decide on what
works for you in terms of <em>system applications</em>, an operating system becomes the
combination of them and the kernel. Thus, Linux is just a <em>kernel</em> and not an
operating system. On the other hand, Ubuntu <em>is</em> an example of a (Linux-based)
operating system, since a typical Ubuntu installation includes the compiled code
of the Linux kernel together with system applications.</p>

<p>How do we tell which operating system we are currently running? Most Linux-based
operating system have some files in the ‘/etc’ folder that contains information
about the distribution name and the installed version. For example, on
Debian-based distributions, this file is typically named <code class="highlighter-rouge">os-release</code>. In my
case, this is what I get if I peek at its content with <code class="highlighter-rouge">cat</code>:</p>

<div class="terminal"><div class="terminal-body flex-container flex-row"><div><pre>
$ cat /etc/os-release
NAME="Ubuntu"
VERSION="18.04 LTS (Bionic Beaver)"
ID=ubuntu
ID_LIKE=debian
PRETTY_NAME="Ubuntu 18.04 LTS"
VERSION_ID="18.04"
HOME_URL="https://www.ubuntu.com/"
SUPPORT_URL="https://help.ubuntu.com/"
BUG_REPORT_URL="https://bugs.launchpad.net/ubuntu/"
PRIVACY_POLICY_URL="https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"
VERSION_CODENAME=bionic
UBUNTU_CODENAME=bionic
</pre></div></div></div>

<h1 id="creating-jails-with-chroot">
<a id="creating-jails-with-chroot" class="anchor" href="#creating-jails-with-chroot" aria-hidden="true"><span class="octicon octicon-link"></span></a>Creating Jails With <code class="highlighter-rouge">chroot</code>
</h1>

<p>One of the earliest examples of “containers” was provided by the use of
<code class="highlighter-rouge">chroot</code>. This is a system call that was introduced in the BSD in 1982 and all
it does is to change the apparent root directory for the process it is called
from, and all its descendant processes.</p>

<p>How can we use such a feature to create a container? Suppose that you have the
root file system of a Linux-based operating system in a sub-folder in your file
system. For example, the new version of your favourite distribution came out and
you want to try the applications it comes with. You can use the <code class="highlighter-rouge">chroot</code> wrapper
application that ships with most if not all Unix-based operating systems these
days to launch the default shell with the apparent root set to
<code class="highlighter-rouge">~/myfavedistro-latest</code>. Assuming that your favourite distribution comes with
most of the standard Unix tools, you will now be able to launch applications
from its latest version, using the services provided by the Linux kernel of the
host machine. Effectively, you are now running an instance of a different
operating system that is using the kernel loaded at boot time from the host
operating system (some sort of Frankenstein OS if you want).</p>

<p>Does what we have just described fit into the above definition of <em>container</em>?
Surely the default shell has its own view of the file system, which is a proper
restriction of the full file system of the host system. As for other resources,
like peripherals etc…, they happen to coincide with the host system, but at
least something is different. If we now look at the content of the <code class="highlighter-rouge">os-release</code>
file in the <code class="highlighter-rouge">/etc</code> folder (or the equivalent for the distribution of your
choice), you will quite likely see something different from before, so indeed we
have a running instance of a different operating system.</p>

<p>The term that is usually associated to <code class="highlighter-rouge">chroot</code> is <em>jail</em> rather than
<em>container</em> though. Indeed, a process that is running within a new apparent root
file system cannot see the content of the parent folders and therefore it is
confined in a corner of the full, actual file system on the physical host. The
modified environment that we see from a shell started with chroot is sometimes
referred to as a <em>chroot jail</em>. But perhaps another reason why the term <em>jail</em>
is being used is that, without the due precautions, it is relatively easy to
break out of one (well, OK, maybe that’s not an official reason).</p>

<p>If the above discussion sounds a bit too abstract to you then don’t worry
because we are about to get hour hands dirty with <code class="highlighter-rouge">chroot</code>.</p>

<h2 id="a-minimal-chroot-jail">
<a id="a-minimal-chroot-jail" class="anchor" href="#a-minimal-chroot-jail" aria-hidden="true"><span class="octicon octicon-link"></span></a>A Minimal <code class="highlighter-rouge">chroot</code> Jail</h2>

<p>Since a <code class="highlighter-rouge">chroot</code> jail is pretty much like a <em>Bring Your Own System Application</em>
party, with the kernel kindly offered by the host, a minimal <code class="highlighter-rouge">chroot</code> jail can
be obtained with just the binary of a shell, and just a few other binary files.
Let’s try and create one with just <code class="highlighter-rouge">bash</code> in it then. Under the assumption
that you have it installed on your Linux system, we can determine all the
shared object the <code class="highlighter-rouge">bash</code> shell depends on with <code class="highlighter-rouge">ldd</code></p>

<div class="terminal"><div class="terminal-body flex-container flex-row"><div><pre>
$ ldd `which bash`
        linux-vdso.so.1 =&gt;  (0x00007ffca3bca000)
        libtinfo.so.5 =&gt; /lib/x86_64-linux-gnu/libtinfo.so.5 (0x00007f9605411000)
        libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f960520d000)
        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f9604e2d000)
        /lib64/ld-linux-x86-64.so.2 (0x00007f960563a000)
</pre></div></div></div>

<p>So let’s create a folder that will serve as the new root file system, e.g.
<code class="highlighter-rouge">~/minimal</code>, and copy the bash executable in it, together with all its
dependencies. Copy the <code class="highlighter-rouge">bash</code> executable inside <code class="highlighter-rouge">~/minimal/bin</code>, the libraries
from <code class="highlighter-rouge">/lib</code> into <code class="highlighter-rouge">~/minimal/lib</code> and those from <code class="highlighter-rouge">/lib64</code>into <code class="highlighter-rouge">~/minimal/lib64</code>.
Then start the <code class="highlighter-rouge">chroot</code> jail with</p>

<div class="terminal"><div class="terminal-body flex-container flex-row">
<div class="pad-right"><pre># </pre></div>
<div><pre>
chroot ~/minimal
</pre></div>
</div></div>

<p>You should now have a running bash session with a vanilla prompt format that
looks like this</p>

<div class="terminal"><div class="terminal-body flex-container flex-row">
<div class="pad-right"><pre># </pre></div>
<div><pre>
bash-4.4#
</pre></div>
</div></div>

<p>Note that <code class="highlighter-rouge">chroot</code> is being executed as the <code class="highlighter-rouge">root</code> user. This is because, under normal
circumstances, only <code class="highlighter-rouge">root</code> has the POSIX <em>capability</em> of calling the
<code class="highlighter-rouge">SYS_CHROOT</code> system call.</p>

<blockquote>
  <p>To see the current capabilities of a user one can use the <code class="highlighter-rouge">capsh --print</code>
  command. The <code class="highlighter-rouge">Bounding set</code> line shows the capabilities that have been
  inherited and that can be granted to a process from the current user.
  Capabilities represent another feature that is relevant for containers. They
  will be discussed in a separate post.</p>
</blockquote>

<p>If you now play around a bit with this bash session, you will realise pretty
quickly that there isn’t much that you can do. Most of the standard Unix tools
are not available, not even <code class="highlighter-rouge">ls</code>. This container that we created as a <code class="highlighter-rouge">chroot</code>
jail is indeed minimal.</p>

<h2 id="a-more-interesting-example">
<a id="a-more-interesting-example" class="anchor" href="#a-more-interesting-example" aria-hidden="true"><span class="octicon octicon-link"></span></a>A More Interesting Example</h2>

<p>Ubuntu has, since version 12.04, released base images of the operating system.
These are just root file system images in the format of a compressed tarball.
Suppose that a new stable version has come out and you want to give it a try
before you upgrade your system. One thing you can do is to go to the <a href="http://cdimage.ubuntu.com/ubuntu-latest/releases/">Ubuntu
Base releases</a> page and
download the image that you want to test. Extract the content of the tarball
somewhere, e.g. <code class="highlighter-rouge">~/ubuntu-latest</code> and “run” it with <code class="highlighter-rouge">chroot</code></p>

<div class="terminal"><div class="terminal-body flex-container flex-row">
<div class="pad-right"><pre># </pre></div>
<div><pre>
chroot ~/ubuntu-latest
</pre></div>
</div></div>

<p>We are now running an instance of a new version of Ubuntu. To check that this is
indeed the case, look at the output of <code class="highlighter-rouge">cat /etc/os-release</code>. Furthermore, we
now have access to all the basic tools that make up the Ubuntu operating system.
For instance you could use aptitude to download and install new packages, which
could be useful to test the latest version of an application.</p>

<p>If you intend to do some serious work with these kinds of <code class="highlighter-rouge">chroot</code> jails, keep
in mind that some of the pseudo-file systems won’t be available from within the
jail. That’s why you would have to mount them manually with</p>

<div class="terminal"><div class="terminal-body flex-container flex-row">
<div class="pad-right"><pre># 
# 
# </pre></div>
<div><pre>
mount -t proc proc proc/
mount -t sysfs sys sys/
mount -o bind /dev dev/
</pre></div>
</div></div>

<p>This way you will be able to use, e.g., <code class="highlighter-rouge">ps</code> to look at the currently running
processes.</p>

<h2 id="leaky-containers">
<a id="leaky-containers" class="anchor" href="#leaky-containers" aria-hidden="true"><span class="octicon octicon-link"></span></a>Leaky Containers</h2>

<p>With the simplicity of <code class="highlighter-rouge">chroot</code> jails comes many issues that make these kind of
“containers” <em>leaky</em>. What do I mean by this? Suppose that you want to
<em>containerise</em> two resource-intensive applications into two different <code class="highlighter-rouge">chroot</code>
jails (for example, the two applications, for some reasons, require different
Linux-based operating systems). A typical example these days is that of
microservices that we would like to run on the same host machine. When the first
microservice fires up, it starts taking all the system resources (like CPU time
for instance), leaving no resources for the second microservice. The same can
happen for network bandwidth utilisation or disk I/O rates.</p>

<p>Unfortunately, this issue cannot be addressed within <code class="highlighter-rouge">chroot</code> jails, and their
usefulness is somewhat restricted. Whilst we can use it to create some sort of
“ancestral” containers, this is not the solution we would turn to in the long
run.</p>

<p>Another serious issue with a poorly implemented <code class="highlighter-rouge">chroot</code> jail is the dreaded
S-word: <em>security</em>. If nothing is done to prevent the user of the jail from
calling certain system calls (e.g. <code class="highlighter-rouge">chroot</code> itself), it is relatively
straightforward to <em>break out</em> of it. Recall how the <code class="highlighter-rouge">chroot</code> wrapper utility
requires <code class="highlighter-rouge">root</code> privileges to be executed. When we launched a bash session
within the Ubuntu Base root file system, we were logged in as the root user.
Without any further configuration, nothing will prevent us from coding a simple
application that performs the following steps from within the jail:</p>

<ol>
  <li>Create a folder with the <code class="highlighter-rouge">mkdir</code> system call or Unix wrapper tool.</li>
  <li>Call the <code class="highlighter-rouge">chroot</code> system call to change the apparent root to the newly
created folder.</li>
  <li>Attempt to navigate sufficiently many levels up to hit the actual file system
root.</li>
  <li>Launch a shell.</li>
</ol>

<p>Why does this work? A simple call to the <code class="highlighter-rouge">chroot</code> system call only changes the
apparent root file system, but doesn’t actually change the current working
directory. The Unix <code class="highlighter-rouge">chroot</code> wrapper tool performs a combination of <code class="highlighter-rouge">chdir</code>
<em>followed</em> by <code class="highlighter-rouge">chroot</code> to actually put the calling process inside the jail.</p>

<blockquote>
  <p>A minimal version of the <code class="highlighter-rouge">chroot(2)</code> utility written in x86-64 assembly code
  can be found in the
  <a href="https://github.com/P403n1x87/asm/blob/master/chroot/minichroot.asm"><code class="highlighter-rouge">minichroot.asm</code></a>
  source file within the GitHub repository linked to this post.</p>
</blockquote>

<p>A call to <code class="highlighter-rouge">chroot</code> which is not preceded by a call to <code class="highlighter-rouge">chdir</code> moves the jail
boundary <em>over</em> the current location down another level, so that we are
effectively out of the jail. This means that we can <code class="highlighter-rouge">chdir</code> up many times now to
try and hit the actual root of the host file system. Now run a shell session and
bang! We have full control of the host file system under the root user! Scary,
isn’t it?</p>

<blockquote>
  <p>If you want to give this method a try, have a look at the
  <a href="https://github.com/P403n1x87/asm/blob/master/chroot/jailbreak.asm"><code class="highlighter-rouge">jailbreak.asm</code></a>
  source file within the GitHub repository linked to this post.</p>
</blockquote>

<p>A less serious matter, but still something that you might want to address, is
that, after we have mounted the <code class="highlighter-rouge">proc</code> file system within the jail, the view of
the running processes from within the jail is the same as the one from the host
system. Again, if we do nothing to strip down capabilities from the <code class="highlighter-rouge">chroot</code>
jail user, any process on the host machine can easily be killed (in the best
hypothesis) by the jail user. Indeed, <code class="highlighter-rouge">chroot</code> containers really require a lot
of care to prevent unwanted information from leaking. That is why present days
containers make use of a different approach to guarantee “airtight” walls, as we
shall soon see.</p>

<h1 id="control-groups">
<a id="control-groups" class="anchor" href="#control-groups" aria-hidden="true"><span class="octicon octicon-link"></span></a>Control Groups</h1>

<p>As we have argued above, when we make use of containers we might want to run
multiple instances of them on the same machine. The problem that we face is
physical resource sharing among the containers. How can we make sure that a
running instance of a containerised process doesn’t eat up all the available
resources from the host machine?</p>

<p>The answer is provided by a feature of the Linux kernel known as <strong>control
groups</strong>. Usually abbreviated as <code class="highlighter-rouge">cgroups</code>, control groups  were initially
released in 2007, based on earlier work of Google engineers, and originally
named <em>process containers</em>.</p>

<p>Roughly speaking, <em>cgroups</em> allow you to limit, account for and isolate system
resources usage among running processes. As a simple example, consider the
scenario where one of your applications has a bug and starts leaking memory in
an infinite loop. Slowly but inevitably, your process ends up using all the
physical memory available on the machine it is running on, causing some of the
other processes to be killed at random by the OOM (Out of Memory) killer or, in
the worst case, crashing the entire system. If only you could assign a slice of
memory to the process that you want to test, then OOM killer would get rid of
only your faulty process, thus preventing your entire system from collapsing and
allowing the other applications to run smoothly without consequences. Well, this
is exactly one of the problems that <em>cgroups</em> allow you to solve.</p>

<p>But physical memory is only one of the aspects (or <em>subsystem</em>, in the language
of <em>cgroups</em>; another term that is used interchangeably is <em>controller</em>) that
can be limited with the use of control groups. CPU cycles, network bandwidth,
disk I/O rate are other examples of resources that can be accounted for with
control groups. This way you can have two or more CPU-bound applications running
happily on the same machine, just by splitting the physical computing power
among them.</p>

<h2 id="a-hierarchy-of-cgroups">
<a id="a-hierarchy-of-cgroups" class="anchor" href="#a-hierarchy-of-cgroups" aria-hidden="true"><span class="octicon octicon-link"></span></a>A Hierarchy of cgroups</h2>

<p>Linux processes are organised in a hierarchical structure. At boot, the <code class="highlighter-rouge">init</code>
process, with PID 1, is spawned, and every other process originates from it as a
child process. This hierarchical structure is visible from the virtual file
system mounted at <code class="highlighter-rouge">/proc</code>.</p>

<p>Cgroups have a similar hierarchical structure but, contrary to processes (also
known as <em>tasks</em> in <em>cgroup</em>-speak), there may be <em>many</em> of such hierarchies of
cgroups. This is the case for cgroups v1, but starting with version 2,
introduced in 2015, cgroups follow a unified hierarchic structure. It is
possible to use the two at the same time, thus having a hybrid cgroups resource
management, even though this is discouraged.</p>

<p>Every cgroups inherits features from the parent cgroups and in general they can
get more restrictive the further you move down the hierarchy, without the
possibility of having overrides. Processes are then spawned or moved/assigned to
cgroups so that each process is in exactly one cgroup at any given time.</p>

<p>This is, in a nutshell, what cgroups and cgroups2 are. A full treatment of
cgroups would require a post on its own and it would take us off-topic. If you
are curious to find out more about their history and their technical details,
you can have a look at the official documentation
<a href="https://www.kernel.org/doc/Documentation/cgroup-v1/cgroups.txt">here</a> and
<a href="https://www.kernel.org/doc/Documentation/cgroup-v2.txt">here</a>.</p>

<h2 id="how-to-work-with-control-groups">
<a id="how-to-work-with-control-groups" class="anchor" href="#how-to-work-with-control-groups" aria-hidden="true"><span class="octicon octicon-link"></span></a>How to Work with Control Groups</h2>

<p>Let’s have a look at how to use cgroups to limit the total amount of physical
(or resident) memory that a process is allowed to use. The example is based on
cgroups v1 since they are still in use today even though cgroups v2 are
replacing them and there currently is an on-going effort of migrating from v1 to
v2.</p>

<p>Since the introduction of cgroups in the Linux kernel, <em>every</em> process belongs
to one and only one cgroup at any given time. By default, there is only one
cgroup, the <em>root</em> cgroup, and every other process, together with its children,
is in it.</p>

<p>Control groups are manipulated with the use of file system operations on the
cgroup mount-point (usually <code class="highlighter-rouge">/sys/fs/cgroup</code>). For example, a new cgroup can be
created with the <code class="highlighter-rouge">mkdir</code> command. Values can be set by writing on the files that
the kernel will create in the subfolder, and the simplest way is to just use
<code class="highlighter-rouge">echo</code>. When a cgroup is no longer needed, it can be removed with <code class="highlighter-rouge">rmdir</code> (<code class="highlighter-rouge">rm
-r</code> should not be used as an alternative!). This will effectively deactive the
cgroup only when the last process in it has terminated, or if it only contains
zombie processes.</p>

<p>As an example, let’s see how to create a cgroup that restricts the amount of
total physical memory processes can use.</p>

<div class="terminal"><div class="terminal-body flex-container flex-row">
<div class="pad-right"><pre># 
# 
# </pre></div>
<div><pre>
mkdir /sys/fs/cgroup/memory/mem_cg
echo 100m &gt; /sys/fs/cgroup/memory/mem_cg/memory.limit_in_bytes
echo 100m &gt; /sys/fs/cgroup/memory/mem_cg/memory.memsw.limit_in_bytes
</pre></div>
</div></div>

<blockquote>
  <p>If <code class="highlighter-rouge">memory.memsw.*</code> is not present in <code class="highlighter-rouge">/sys/fs/cgroup/memory</code>, you might need
  to enable it on the kernel by adding the parameters <code class="highlighter-rouge">cgroup_enable=memory
  swapaccount=1</code> to, e.g., GRUB’s <em>kernel line</em>. To do so, open
  <code class="highlighter-rouge">/etc/default/grub</code> and append these parameters to
  <code class="highlighter-rouge">GRUB_CMDLINE_LINUX_DEFAULT</code>.</p>
</blockquote>

<p>Any process running in the <code class="highlighter-rouge">mem_cg</code> cgroup will be constrained to a total amount
(that is, physical plus swap) of memory equal to 100 MB. When a process gets
above the limit, the OOM killer will get rid of it. To add a process to the
<code class="highlighter-rouge">mem_cg</code> cgroup we have to write its PID to the <code class="highlighter-rouge">tasks</code> file, e.g. with</p>

<div class="terminal"><div class="terminal-body flex-container flex-row">
<div class="pad-right"><pre># </pre></div>
<div><pre>
echo $$ &gt; /sys/fs/cgroup/memory/mem_cg/tasks
</pre></div>
</div></div>

<p>This will put the currently running shell into the <code class="highlighter-rouge">mem_cg</code> cgroup. When we want
to remove the cgroup, we can just delete its folder with</p>

<div class="terminal"><div class="terminal-body flex-container flex-row">
<div class="pad-right"><pre># </pre></div>
<div><pre>
rmdir /sys/fs/cgroup/memory/mem_cg
</pre></div>
</div></div>

<p>Note that, even if fully removed from the virtual file system, any removed
cgroups remain active until all the associated processes have terminated or have
become zombies.</p>

<p>Alternatively, one can work with cgroups by using the tools provided by
<code class="highlighter-rouge">libcgroup</code> (Red Hat), or <code class="highlighter-rouge">cgroup-tools</code> (Debian). Once installed with the
corresponding package managers, the above commands can be replaced with the
following, perhaps more intuitive ones:</p>

<div class="terminal"><div class="terminal-body flex-container flex-row">
<div class="pad-right"><pre># 
# 
# 
# 
# </pre></div>
<div><pre>
cgcreate -g memory:mem_cg
cgset -r memory.limit_in_bytes=100m
cgset -r memory.memsw.limit_in_bytes=100m
cgclassify -g memory:mem_cg $$
cgdelete memory:mem_cg
</pre></div>
</div></div>

<p>One can use <code class="highlighter-rouge">cgexec</code> as an alternative to start a new process directly within a
cgroup:</p>

<div class="terminal"><div class="terminal-body flex-container flex-row">
<div class="pad-right"><pre># </pre></div>
<div><pre>
cgroup -g memory:mem_cg /bin/bash
</pre></div>
</div></div>

<p>We can test that the memory cgroup we have created works with the following
simple C program</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include "stdlib.h"
#include "stdio.h"
#include "string.h"
</span>
<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span>    <span class="n">a</span>      <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">*</span> <span class="n">buffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

  <span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">buffer</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"Allocation #%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
      <span class="n">memset</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>We have created an infinite loop in which we allocate chunks of 1 MB of memory
at each iteration. The call to <code class="highlighter-rouge">memset</code> is a trick to force the Linux kernel to
actually allocate the requested memory under the copy-on-write strategy.</p>

<p>Once compiled, we can run it into the <code class="highlighter-rouge">mem_cg</code> cgroup with</p>

<div class="terminal"><div class="terminal-body flex-container flex-row">
<div class="pad-right"><pre># </pre></div>
<div><pre>
cgexec -g mem_cg ./a.out
</pre></div>
</div></div>

<p>We expect to see about 100 successful allocations and after that the OOM killer
intervenes to stop our processes, since it would have reached the allocated
memory quota by then.</p>

<p>Imagine now launching a <code class="highlighter-rouge">chroot</code> jail inside a memory cgroup like the one we
created above. Every application that we launch from within it is automatically
created inside the same cgroup. This way we can run, e.g., a microservice and we
can be assured that it won’t eat up all the available memory from the host
machine. With a similar approach, we could also make sure that it won’t reserve
all the CPU and its cores to itself, thus allowing other processes (perhaps in
different jails/containers) to run simultaneously and smoothly on the same
physical machine.</p>

<h1 id="linux-namespaces">
<a id="linux-namespaces" class="anchor" href="#linux-namespaces" aria-hidden="true"><span class="octicon octicon-link"></span></a>Linux Namespaces</h1>

<p>The description of Linux namespaces given by the dedicated manpage sums up the
concept pretty well:</p>

<blockquote>
  <p>A namespace wraps a global system resource in an abstraction that
  makes it appear to the processes within the namespace that they have
  their own isolated instance of the global resource.  Changes to the
  global resource are visible to other processes that are members of
  the namespace, but are invisible to other processes.  One use of
  namespaces is to implement containers.</p>
</blockquote>

<p>So no questions asked about why Linux namespaces were introduced in the first
place. As the description says, they are used to allow processes to have their
own copy of a certain physical resource. For example, the most recent versions
of the Linux kernel allow us to define a namespace of the <strong>network</strong> kind, and
every application that we run under it will have its own copy of the full
network stack. We have pretty much a rather lightweight way of virtualising an
entire network!</p>

<p>Linux namespaces represent a relatively new feature that made its first
appearance in 2002 with the <strong>mount</strong> kind. Since there were no plans to have
different kinds of namespaces, at that time the term <em>namespace</em> was synonym of
<em>mount</em> namespace. Beginning in 2006, more kinds were added and, presently,
there are plans for new kinds to be developed and included in future releases of
the Linux kernel.</p>

<p>If you really want to identify a single feature that makes modern Linux
container possible, namespaces is arguably the candidate. Let’s try to see why.</p>

<h2 id="some-implementation-details">
<a id="some-implementation-details" class="anchor" href="#some-implementation-details" aria-hidden="true"><span class="octicon octicon-link"></span></a>Some Implementation Details</h2>

<p>In order to introduce namespaces in Linux, a new system call, <code class="highlighter-rouge">unshare</code>, has
been added to the kernel. Its use is “to allow a process to control its shared
execution context without creating a new process.” (quoted verbatim from the
manpage of <code class="highlighter-rouge">unshare(2)</code>). What does this mean? Suppose that, at a certain point,
you want the current process to be moved to a new network namespace so that it
has its own “private” network stack. All you have to do is make a call to the
<code class="highlighter-rouge">unshare</code> system call with the appropriate flag set.</p>

<p>What if we do want to spawn a new process in a new namespace instead? With the
introduction of namespaces, the existing <code class="highlighter-rouge">clone</code> system call has been extended
with new flags. When <code class="highlighter-rouge">clone</code> is called with some of these flags set, new
namespaces of the corresponding kinds are created and the new process is
automatically made a member of them.</p>

<p>The namespace information of the currently running processes is stored in the
<code class="highlighter-rouge">proc</code> file system, under the new <code class="highlighter-rouge">ns</code> subfolder of every PID folder (i.e.
<code class="highlighter-rouge">/proc/[pid]/ns/</code>). This as well as other details of how namespaces are
implemented can be found in the
<a href="http://man7.org/linux/man-pages/man7/namespaces.7.html"><code class="highlighter-rouge">namespaces(7)</code></a>
manpage.</p>

<h2 id="how-to-work-with-namespaces">
<a id="how-to-work-with-namespaces" class="anchor" href="#how-to-work-with-namespaces" aria-hidden="true"><span class="octicon octicon-link"></span></a>How to Work with Namespaces</h2>

<p>As with cgroups, an in-depth description of namespaces would require a post on
its own. So we will have a look at just one simple example. Since networks are
ubiquitous these days, let’s try to launch a process that has its own
virtualised network stack and that is capable of communicating with the host
system via a network link.</p>

<p>This is the plan:</p>

<ol>
  <li>Create a linked pair of virtual ethernet devices, e.g. <code class="highlighter-rouge">veth0</code> and <code class="highlighter-rouge">veth1</code>.</li>
  <li>Move <code class="highlighter-rouge">veth1</code> to a new network namespace</li>
  <li>Assign IP addresses to the virtual NICs and bring them up.</li>
  <li>Test that the can transfer data between them.</li>
</ol>

<p>Here is a simple bash script that does exactly this. Note that the creation of a
network namespace requires a capability that normal Unix user don’t usually
have, so this is why you will need to run them as, e.g., root.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td>
<td class="code"><pre><span class="c"># Create a new network namespace</span>
ip netns add <span class="nb">test</span>

<span class="c"># Create a pair of virtual ethernet interfaces</span>
ip <span class="nb">link </span>add veth0 <span class="nb">type </span>veth peer name veth1

<span class="c"># Configure the host virtual interface</span>
ip addr add 10.0.0.1/24 dev veth0
ip <span class="nb">link set </span>veth0 up

<span class="c"># Move the guest virtual interface to the test namespace</span>
ip <span class="nb">link set </span>veth1 netns <span class="nb">test</span>

<span class="c"># Configure the guest virtual interface in the test namespace</span>
ip netns <span class="nb">exec test </span>bash
ip addr add 10.0.0.2/24 dev veth1
ip <span class="nb">link set </span>veth1 up

<span class="c"># Start listening for TCP packets on port 2000</span>
nc <span class="nt">-l</span> 2000</pre></td>
</tr></tbody></table></code></pre></figure>

<p>On line 2 we use the extended, namespace-capable version of <code class="highlighter-rouge">ip</code> to create a new
namespace of the network kind, called <code class="highlighter-rouge">test</code>. We then create the pair of virtual
ethernet devices with the command on line 5. On line 12 we move the <code class="highlighter-rouge">veth1</code>
device to the <code class="highlighter-rouge">test</code> namespace and, in order to configure it, we launch a bash
session inside <code class="highlighter-rouge">test</code> with the command on line 15. Once in the new namespace we
can see the <code class="highlighter-rouge">veth1</code> device again, which has now disappeared from the default
(also known as <em>global</em>) namespace. You can check that by opening a new terminal
and typing <code class="highlighter-rouge">ip link list</code>. The <code class="highlighter-rouge">veth1</code> device should have disappeared after the
execution of the command on line 12.</p>

<p>We can then use <code class="highlighter-rouge">netcat</code> to listen to TCP packets being sent on port 2000 from
within the new namespace (line 20). On a new bash session in the default
namespaces, we can start <code class="highlighter-rouge">netcat</code> with</p>

<div class="terminal"><div class="terminal-body flex-container flex-row">
<div class="pad-right"><pre>$ </pre></div>
<div><pre>
nc 10.0.0.2 2000
</pre></div>
</div></div>

<p>to start sending packets to the new namespace <code class="highlighter-rouge">test</code> via the link between
<code class="highlighter-rouge">veth0</code> and <code class="highlighter-rouge">veth1</code>. Everything that you type should now be echoed by the bash
session in the <code class="highlighter-rouge">test</code> namespace after you press Enter.</p>

<h1 id="putting-it-all-together">
<a id="putting-it-all-together" class="anchor" href="#putting-it-all-together" aria-hidden="true"><span class="octicon octicon-link"></span></a>Putting It All Together</h1>

<p>Now let’s see how to put all the stuff we have discussed thus far together to
handcraft some more (better) containers.</p>

<h2 id="process-containment-for-chroot-jails">
<a id="process-containment-for-chroot-jails" class="anchor" href="#process-containment-for-chroot-jails" aria-hidden="true"><span class="octicon octicon-link"></span></a>Process Containment for <code class="highlighter-rouge">chroot</code> Jails</h2>

<p>With our first attempt at manually crafting a container with <code class="highlighter-rouge">chroot</code>, we
discovered a few weaknesses of different nature that made the result quite
leaky. Let’s try to address some of those issues, for instance the fact that all
the processes running on the host system are visible from within the container.
To this end, we shall make use of the Ubuntu Base image that we used in the
<code class="highlighter-rouge">chroot</code> section. We then combine <code class="highlighter-rouge">chroot</code> with namespaces in the following way.
Assuming that you have created the <code class="highlighter-rouge">test</code> network namespace as described in the
previous section, run</p>

<div class="terminal"><div class="terminal-body flex-container flex-row">
<div class="pad-right"><pre># </pre></div>
<div><pre>
unshare --fork -p -u ip netns exec test chroot ubuntu-latest
</pre></div>
</div></div>

<p>The <code class="highlighter-rouge">--fork</code> switch is required by the <code class="highlighter-rouge">-p</code> switch because we want to spawn a
new bash session with PID 1, rather than within the calling process. The <code class="highlighter-rouge">-u</code>
switch will give us a new hostname that we are then free to change without that
affecting the host system. We then use the <code class="highlighter-rouge">ip</code> new capability of creating
namespaces of the network kind to create the Ubuntu Base <code class="highlighter-rouge">chroot</code> jail.</p>

<p>The first improvement is now evident. From inside the <code class="highlighter-rouge">chroot</code> jail, mount the
<code class="highlighter-rouge">proc</code> file system with, e.g.</p>

<div class="terminal"><div class="terminal-body flex-container flex-row">
<div class="pad-right"><pre># </pre></div>
<div><pre>
mount -t proc proc /proc
</pre></div>
</div></div>

<p>and then look at the output of <code class="highlighter-rouge">ps aux</code>:</p>

<div class="terminal"><div class="terminal-body flex-container flex-row"><div><pre>
# ps -ef
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 11:54 ?        00:00:00 /bin/bash -i
root         8     1  0 11:56 ?        00:00:00 ps -ef
</pre></div></div></div>

<p>The bash session that we started inside the <code class="highlighter-rouge">chroot</code> jail has PID 1 and the <code class="highlighter-rouge">ps</code>
tool from the Ubuntu Base distribution has PID 8 and parent PID 1, i.e. the
<code class="highlighter-rouge">chroot</code> jail. That’s all the processes that we can see from here! If we try to
identify this bash shell from the global namespace we find something like this</p>

<div class="terminal"><div class="terminal-body flex-container flex-row"><div><pre>
$ ps -ef | grep unshare | grep -v grep
root      5829  4957  0 12:54 pts/1    00:00:00 sudo unshare --fork -p -u ip netns exec test chroot ubuntu-latest
root      5830  5829  0 12:54 pts/1    00:00:00 unshare --fork -p -u ip netns exec test chroot ubuntu-latest
</pre></div></div></div>

<p>PIDs in your case will quite likely be different, but the point here is that,
with namespaces, we have broken the assumption that a process has a <em>unique</em>
process ID.</p>

<h2 id="wall-fortification">
<a id="wall-fortification" class="anchor" href="#wall-fortification" aria-hidden="true"><span class="octicon octicon-link"></span></a>Wall Fortification</h2>

<p>Whilst the process view problem has been solved (we can no longer kill the host
processes since we cannot see them), the fact that the <code class="highlighter-rouge">chroot</code> jail runs as
root still leaves us with the <em>jailbreak</em> issue. To fix this we just use
namespaces again the way they where meant to be used originally. Recall that,
when they were introduced, namespaces were of just one kind: mount. In fact,
back then, namespaces was a synonym of <em>mount</em> namespace.</p>

<p>The other ingredient that is needed to actually secure against jail breaking is
the <code class="highlighter-rouge">pivot_root</code> system call. At first sight it might look like <code class="highlighter-rouge">chroot</code>, but it
is quite different. It allows you to put the old root to a new location and use
a new mount point as the new root for the calling process.</p>

<p>The key here is the combination of <code class="highlighter-rouge">pivot_root</code> and the namespace of the kind
mount that allows us to specify a new root and manipulate the mount points that
are visible inside the container that we want to create, without messing about
with the host mount points. So here is the general idea and the steps required:</p>

<ol>
  <li>Start a shell session from a shell executable inside the root file system in
a mount namespace.</li>
  <li>Unmount all the current mount points, including that of type <code class="highlighter-rouge">proc</code>.</li>
  <li>Turn the Ubuntu Base root file system into a (bind) mount point</li>
  <li>Use <code class="highlighter-rouge">pivot_root</code> and `chroot to swap the new root with the old one</li>
  <li>Unmount the new location of the old root to conceal the full host file
system.</li>
</ol>

<p>The above steps can be performed with the following initialisation script.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">umount <span class="nt">-a</span>
umount /proc
mount <span class="nt">--bind</span> ubuntu-latest/ ubuntu-latest/
<span class="nb">cd </span>ubuntu-latest/
<span class="nb">test</span> <span class="nt">-d</span> old-root <span class="o">||</span> <span class="nb">mkdir </span>old-root
pivot_root <span class="nb">.</span> old-root/
<span class="nb">exec chroot</span> <span class="nb">.</span> /bin/bash <span class="nt">--init-file</span> &lt;<span class="o">(</span>mount <span class="nt">-t</span> proc proc /proc <span class="o">&amp;&amp;</span> umount <span class="nt">-l</span> /old-root<span class="o">)</span></code></pre></figure>

<p>Copy and paste these lines in a file, e.g. <code class="highlighter-rouge">cnt-init.sh</code> and then run</p>

<div class="terminal"><div class="terminal-body flex-container flex-row">
<div class="pad-right"><pre># </pre></div>
<div><pre>
sudo unshare --fork -p -u -m ubuntu-latest/bin/bash --init-file cnt-init.sh
</pre></div>
</div></div>

<p>You can now check that the <code class="highlighter-rouge">/old-root</code> folder is empty, meaning that we now have
no ways of accessing the full host file system, but only the corner that
corresponds to the content of the new root, i.e. the content of the
<code class="highlighter-rouge">ubuntu-latest</code> folder. Furthermore, you can go on and check that our recipe for
breaking out of a vanilla <code class="highlighter-rouge">chroot</code> jail does not work in this case, because the
jail itself is now an effective, rather than apparent, root!</p>

<h1 id="conclusions">
<a id="conclusions" class="anchor" href="#conclusions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Conclusions</h1>

<p>We have come to the end of this journey across the features of the Linux kernel
that make containers possible. I hope this has given you a better understanding
of what many people mean when they say that containers are like virtual
machines, but are <em>not</em> virtual machine.</p>

<p>Whilst spinning containers by hand could be fun, and quite likely an interesting
educational experience for many, to actually produce something that is robust
and secure enough requires some effort. Even in our last examples there are many
things that need to be improved, starting from the fact that we would want to
avoid giving control of our containers to users as root. Despite all our effort
to improve containment of resources, an user logged in as root can still do some
nasty things (open lower-numbered ports and all such kind of businesses…). The
point here is that, if you need containers for production environments, you
should turn to well tested and established technologies, like LXC, Docker etc…
.</p>

    </div>

    <div class="comments">
  <h1>Comments</h1>

  
    
    
    <ul class="comment-list">
      
        
        
      
    </ul>
  

  <h2 id="comment-hdr">Leave a comment</h2>
  <script src="https://p403n1x87.github.io//js/comments.js"></script>

<form id     = "post-comment"
      class  = "comment"
      method = "post"
      action = "">

  <input type        = "text"
         name        = "fields[name]"
         id          = "name"
         placeholder = "Name"/>

  <input type        = "text"
         name        = "fields[email]"
         placeholder = "E-mail address (optional; stored hashed for privacy)"/>

  <textarea name        = "fields[comment]"
            id          = "comment"
            rows        = "5"
            placeholder = "Write your comment here. You can use markdown and LaTeX (use $...$ to inline)"></textarea>

  <button type  = "button"
          class = "flat_button"
          id    = "btn-submit-comment"
          onClick="submitComment();">
    SUBMIT FOR APPROVAL
  </button>


  <!-- Hidden fields -->

   <input type  = "hidden"
          name  = "fields[pic]"
          value = "containers"/>

    <input type  = "hidden"
           id    = "timestamp"
           name  = "fields[timestamp]"
           value = "1557091937"/>

    <input type  = "hidden"
           id    = "parent"
           name  = "fields[parent]"
           value = "0"/>

</form>

<div id="snackbar"></div>


</div>

  </div>
</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The Hub of Heliopolis</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>The Hub of Heliopolis is maintained by Gabriele N. Tornetta</li>
          <li><a href="mailto:phoenix1987@gmail.com">phoenix1987@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <i class="fa fa-github" aria-hidden="true"></i>&nbsp;<a href="https://github.com/P403n1x87"><span class="username">P403n1x87</span></a>

          </li>
          

          

          <li>
            <i class="fa fa-rss-square" aria-hidden="true"></i>&nbsp;<a href="/feed.xml">Subscribe</a>
          </li>
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The Hub of Heliopolis is the <i>tech bay</i> of <a href="http://thenestofheliopolis.blogspot.co.uk/">The Nest of Heliopolis</a>. It is the home of all my <i>encounters</i> with technology that I consider worth sharing with the World.
</p>
      </div>
    </div>

    <div class="footer-copyright">
      Copyright (C) 2017 Gabriele N. Tornetta. All rights reserved.
    </div>

  </div>

</footer>


    
      <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-104560783-1', 'auto');
  ga('send', 'pageview');

</script>

    

    <script src="https://use.fontawesome.com/8c7b940d60.js"></script>

    <!-- MathJax support -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>


  </body>

</html>
