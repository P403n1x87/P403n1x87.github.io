<!DOCTYPE html>
<html>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>

  
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Getting Started with x86-64 Assembly on Linux</title>
  <meta name="description" content="You have experience of x86 assembly and you wonder what the fundamental architectural differences with the 64 bit Intel architecture are? Then this post migh...">
  <meta name="theme-color" content="#100808" />

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://p403n1x87.github.io//assembly/x86_64/2016/08/10/getting-started-with-x68-asm.html">
  <link rel="alternate" type="application/rss+xml" title="The Hub of Heliopolis" href="https://p403n1x87.github.io//feed.xml">
</head>


  <body>

    <header class="site-header">
  <div class="site-title">
    ~# <a href="/">the-<strong>hub</strong>-of-heliopolis</a><span class="blinking-cursor">&block;</span>
  </div>
  <div class="wrapper">
    <nav class="site-nav">
      <div class="trigger">
        
          
        
          
          <a class="page-link" href="/">Posts</a>
          
        
          
        
          
          <a class="page-link" href="/about/">About</a>
          
        
      </div>
    </nav>

  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <h1 class="post-title" itemprop="name headline">Getting Started with x86-64 Assembly on Linux</h1>

<article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="sidepane post-header">
    
    <div class="post-info">
  <div class="post-detail"><i class="fa fa-calendar-plus-o" aria-hidden="true"></i>&nbsp;2016 Aug 10</div>
  <div class="post-detail"><i class="fa fa-clock-o" aria-hidden="true"></i>&nbsp;<span class="reading-time" title="Estimated read time">
  
  
    a 26 minute read
  
</span>
</div>
  <div class="flex-container flex-row post-detail">
  <div><i class="fa fa-archive" aria-hidden="true"></i></div>&nbsp;
  <div><span class="category">Assembly</span><span class="category">x86_64</span></div>
</div>
<div class="flex-container flex-row post-detail">
  <div><i class="fa fa-tags" aria-hidden="true"></i></div>&nbsp;
  <div class="flex-container flex-row flex-wrap"><span class="tag">Programming</span><span class="tag">Assembly</span><span class="tag">x86_64</span></div>
</div>

  
</div>


    <div class="toc">
      <div class="heading">Table of Contents</div>
      <ul class="section-nav">
<li class="toc-entry toc-h1"><a href="#overview">Overview</a></li>
<li class="toc-entry toc-h1"><a href="#tools">Tools</a></li>
<li class="toc-entry toc-h1"><a href="#hello-syscalls">Hello Syscalls!</a></li>
<li class="toc-entry toc-h1"><a href="#hello-libc">Hello libc!</a></li>
<li class="toc-entry toc-h1"><a href="#conclusions">Conclusions</a></li>
</ul>
    </div>

  </header>

  <div class="post-text">

    <div class="post-excerpt">
      <p>You have experience of x86 assembly and you wonder what the fundamental architectural differences with the 64 bit Intel architecture are? Then this post might be what you are looking for. Here we’ll see how to use the Netwide Assembler (NASM) to write a simple Hello World application in x86_64 assembly. Along the way, we will also have the chance to see how to use some standard tools to optimise the final executable by stripping out unnecessary debug symbols.</p>

    </div>

    <div class="post-content" itemprop="articleBody">
      <p>In this post we will learn how to assemble and link a simple “Hello World” application written in x86-64 assembly for the Linux operating system. If you have experience with Intel IA-32 assembly and you want to quickly get adjusted to the x86-64 world then this post is for you. If you’re trying to learn the assembly language from scratch then I’m afraid this post is not for you. There are many great resources online on 32-bit assembly. One of my favourite documents is Paul Carter’s PC Assembly Language, which I highly recommend if you’re moving your first steps into the assembly language. If you then decide to come back to this post, you should be able to read it with no problems, since the tools that I will employ here are the same used in Carter’s book.</p>

<h1 id="overview">
<a id="overview" class="anchor" href="#overview" aria-hidden="true"><span class="octicon octicon-link"></span></a>Overview</h1>

<p>This post is organised as follows. In the next section, I gather some details about the tools that we will use to code, assemble, link and execute the applications. As already mentioned above, most of the tools are the same as those used in Carter’s book. Our assembler (and hence the syntax) will be NASM. I will make use of two linkers, <code class="highlighter-rouge">ld</code> and the one that comes with <code class="highlighter-rouge">gcc</code>, the GNU C Compiler, for reasons that will be explained later. The first x64 application that we will code will give us the chance to get familiar with the new system calls and how they differ from the 32-bit architecture. With the second one we will make use of the Standard C Library. Both examples will give us the chance to explore the x86-64 calling convention as set out in the <a href="http://www.x86-64.org/documentation/abi.pdf">System V Application Binary Interface</a>.</p>

<p>All the code shown in this post will also be available from the <a href="https://github.com/P403n1x87/asm/tree/master/hello64">dedicated asm GitHub repository</a>.</p>

<h1 id="tools">
<a id="tools" class="anchor" href="#tools" aria-hidden="true"><span class="octicon octicon-link"></span></a>Tools</h1>

<p>The Netwide Assembler is arguably the most popular assembler for the Linux Operating System and it is an open-source project. Its documentation is nicely written and explains all the features of the language and of the (dis)assembler. This post will try to be as much self-contained as possible, but whenever you feel the need to explore something a bit more, the NASM documentation will probably be the right place. To assemble a 64-bit application we will need to use the command</p>

<div class="terminal"><div class="terminal-body flex-container flex-row">
<div class="pad-right"><pre>$ </pre></div>
<div><pre>
nasm -f elf64 -o myapp.o myapp.asm
</pre></div>
</div></div>

<p>The flag <code class="highlighter-rouge">-f elf64</code> instructs NASM that we want to create a 64-bit ELF object file. The flag <code class="highlighter-rouge">-o myapp.o</code> tells the assembler that we want the output object file to be <code class="highlighter-rouge">myapp.o</code> in the current directory, whereas <code class="highlighter-rouge">myapp.asm</code> specifies the name of the source file containing the NASM code to be assembled.</p>

<p>When an application calls functions from shared libraries it is necessary to <em>link</em> our object file to them so that it knows where to find them. Even if we are not using any external libraries, we still need to invoke the linker in order to obtain a valid executable file. The typical usage of <code class="highlighter-rouge">ld</code> that we will encounter in this post is</p>

<div class="terminal"><div class="terminal-body flex-container flex-row">
<div class="pad-right"><pre>$ </pre></div>
<div><pre>
ld -o myapp.o myapp
</pre></div>
</div></div>

<p>This is enough to produce a valid executable when we are not linking our object file <code class="highlighter-rouge">myapp.o</code> against any external shared library or any other object file. Occasionally, depending on your distribution, you will have to specify which interpreter you want to use. This is a library which, for ELF executables, acts as a loader. It loads the application in memory, as well as the required linked shared libraries. On Ubuntu 16.04, the right 64-bit interpreter is at <code class="highlighter-rouge">/lib64/ld-linux-x86-64.so.2</code> and therefore my invocation of <code class="highlighter-rouge">ld</code> will look like</p>

<div class="terminal"><div class="terminal-body flex-container flex-row">
<div class="pad-right"><pre>$ </pre></div>
<div><pre>
ld -o myapp myapp.o -I/lib64/ld-linux-x86-64.so.2
</pre></div>
</div></div>

<p>Some external shared libraries are designed to work with C. It is then advisable to include a <code class="highlighter-rouge">main</code> function in the assembly source code since the Standard C Library will take care of some essential cleanup steps when the execution returns from it. Cases where one might want to opt for this approach are when the application works with file descriptors and/or spawns child processes. We will see an example of this situation in a future tutorial on assembly and Gtk+. For the time being, we shall limit ourselves to see how to use the GNU C Compiler to link our object file with other object files (and in particular with <code class="highlighter-rouge">libc</code>). The typical usage of <code class="highlighter-rouge">gcc</code> will be something like</p>

<div class="terminal"><div class="terminal-body flex-container flex-row">
<div class="pad-right"><pre>$ </pre></div>
<div><pre>
gcc -o myapp.o myapp
</pre></div>
</div></div>

<p>which is very much similar to <code class="highlighter-rouge">ld</code>.</p>

<h1 id="hello-syscalls">
<a id="hello-syscalls" class="anchor" href="#hello-syscalls" aria-hidden="true"><span class="octicon octicon-link"></span></a>Hello Syscalls!</h1>

<p>In this first example we will make use of the Linux system calls to print the string <code class="highlighter-rouge">Hello World!</code> to the screen. Here is where we encounter a major difference between the 32-bit and the 64-bit Linux world.</p>

<p>But before we get to that, let’s have a look at what is probably the most important difference between the 32-bit and the 64-bit architecture: the registers. The number of the general purpose registers (GPRs for short) has doubled and now have a maximum size of … well … 64-bit. The old <code class="highlighter-rouge">EAX</code>, <code class="highlighter-rouge">EBX</code>, <code class="highlighter-rouge">ECX</code> etc… are now the low 32-bit of the larger <code class="highlighter-rouge">RAX</code>, <code class="highlighter-rouge">RBX</code>, <code class="highlighter-rouge">RCX</code> etc… respectively, while the new 8 GPRs are named <code class="highlighter-rouge">R8</code> to <code class="highlighter-rouge">R15</code>. The prefix <code class="highlighter-rouge">R</code> stands for, surprise, surprise, <em>register</em>. This seems like a sensible decision, since this is in line with many other CPU manufacturers. Further details can be found in <a href="http://www.nasm.us/doc/nasmdo11.html">Chapter 11</a> of the NASM documentation and in <a href="https://software.intel.com/sites/default/files/m/d/4/1/d/8/Introduction_to_x64_Assembly.pdf">this Intel white</a>.</p>

<p>Let’s now move back to system calls. Unix systems and derivatives do not make use of software interrupts, with the only exception of <code class="highlighter-rouge">INT 0x80</code>, which on 32-bit systems is used to make system calls. A system call is a way to request a service from the kernel of the operating system. Most C programmers don’t need to worry about them, as the Standard C Library provides wrappers around them. The x86_64 architecture introduced the dedicated instruction <code class="highlighter-rouge">syscall</code> in order to make system calls. You can still use interrupts to make system calls, but <code class="highlighter-rouge">syscall</code> will be faster as it does not access the interrupt descriptor table.</p>

<p>The purpose of this section is to explore this new opcode with an example. Without further ado, let’s dive into some assembly code. The following is the content of my <code class="highlighter-rouge">hello64.asm</code> file.</p>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td>
<td class="code"><pre><span class="kr">global</span> <span class="n">_start</span>

<span class="c">;</span>
<span class="c">; CONSTANTS</span>
<span class="c">;</span>
<span class="n">SYS_WRITE</span>   <span class="k">equ</span> <span class="mi">1</span>
<span class="n">SYS_EXIT</span>    <span class="k">equ</span> <span class="mi">60</span>
<span class="n">STDOUT</span>      <span class="k">equ</span> <span class="mi">1</span>

<span class="c">;</span>
<span class="c">; Initialised data goes here</span>
<span class="c">;</span>
<span class="kr">SECTION</span> <span class="p">.</span><span class="n">data</span>
<span class="n">hello</span>           <span class="kt">db</span>  <span class="s">"Hello World!"</span><span class="p">,</span> <span class="mi">10</span>      <span class="c">; char *</span>
<span class="n">hello_len</span>       <span class="k">equ</span> <span class="err">$</span><span class="o">-</span><span class="n">hello</span>                 <span class="c">; size_t</span>

<span class="c">;</span>
<span class="c">; Code goes here</span>
<span class="c">;</span>
<span class="kr">SECTION</span> <span class="p">.</span><span class="n">text</span>

<span class="n">_start</span><span class="o">:</span>
    <span class="c">; syscall(SYS_WRITE, STDOUT, hello, hello_len);</span>
    <span class="k">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="n">SYS_WRITE</span>
    <span class="k">mov</span>     <span class="n">rdi</span><span class="p">,</span> <span class="n">STDOUT</span>
    <span class="k">mov</span>     <span class="n">rsi</span><span class="p">,</span> <span class="n">hello</span>
    <span class="k">mov</span>     <span class="n">rdx</span><span class="p">,</span> <span class="n">hello_len</span>
    <span class="k">syscall</span>
    <span class="k">push</span>    <span class="n">rax</span>

    <span class="c">; syscall(SYS_EXIT, &lt;sys_write return value&gt; - hello_len);</span>
    <span class="k">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="n">SYS_EXIT</span>
    <span class="k">pop</span>     <span class="n">rdi</span>
    <span class="k">sub</span>     <span class="n">rdi</span><span class="p">,</span> <span class="n">hello_len</span>
    <span class="k">syscall</span></pre></td>
</tr></tbody></table></code></pre></figure>

<p class="caption">hello64.asm</p>

<p>Lines 1, 13, 20 and 22 are part of the skeleton of any NASM source code. With line 1 we export the symbol <code class="highlighter-rouge">_start</code>, which defines the entry point for the application, i.e. the point in where the execution starts from. The actual symbol is declared on line 22, and line 24 will be the fist one to be executed.</p>

<p>In lines 6 to 8 we define some constants to increase the readability of the code. The price to pay is that NASM will export these symbols as well, thus increasing the size of the final executable file. I will discuss how to deal with this later on in this post. For the time being, let’s focus on the rest of the code.</p>

<p>Line 13 marks the beginning of the initialised data section. Here we define strings and other immediate values. In this case we only need to define the <code class="highlighter-rouge">"Hello World!\n"</code> string (<code class="highlighter-rouge">10</code> is the ASCII code for the newline character <code class="highlighter-rouge">\n</code>) and label it <code class="highlighter-rouge">hello</code>. Line 15 defines a constant equals to the length of the string, and this is accomplished by subtracting the address of the label <code class="highlighter-rouge">hello</code> from the current address, given by <code class="highlighter-rouge">$</code> in NASM syntax.</p>

<p>The <code class="highlighter-rouge">.text</code> section, where the actual code resides, starts at line 20. Here we declare the <code class="highlighter-rouge">_start</code> symbol, i.e. the entry point of the application, followed by the code to be executed. In this simple example, all we need to do is print the string to screen and then terminate the application. This means that we need to call the <code class="highlighter-rouge">sys_write</code> system call, followed by a call to <code class="highlighter-rouge">sys_exit</code>, perhaps with an exit code that will tell us whether the call to <code class="highlighter-rouge">sys_write</code> has been successful or not.</p>

<p>Here is our first encounter with the new syscall opcode and the x86_64 calling convention. There isn’t much to say about syscall. It does what you would expect it to do, i.e. make a system call. The system call to make is specified by the value of the rax register, whereas the parameters are passed according to the already mentioned x86_64 calling convention. It is recommended that you have a look at the official documentation to fully grasp it, especially when it comes to complex calls. In a nutshell, some of the parameters are passed through registers and the rest go to the stack. The order of the registers is: <code class="highlighter-rouge">rdi, rsi, rdx, r10, r8, r9</code>. We shall see in the next code example that, when we call a C function, we should use <code class="highlighter-rouge">rcx</code> instead of <code class="highlighter-rouge">r10</code>. Indeed, the latter is only used for the Linux kernel interface, while the former is used in all the other cases.</p>

<p>On line 23 we have a comment that shows us the equivalent C code for a call to sys_write. Its “signature” is the following.</p>

<div style="background-color: #202000;padding:24px;margin:12px;font-size:80%;">
  <table>
    <tbody>
      <tr>
        <th>1. SYS_WRITE</th>
      </tr>
      <tr>
        <td style="padding-top:.5em;font-weight:bold;">Parameters</td>
      </tr>
      <tr>
        <td>
          <table style="padding-left:1em;">
            <tbody>
              <tr>
                <td style="font-family: monospace;padding-right:12px;">unsigned int</td>
                <td>file descriptor</td>
              </tr>
              <tr>
                <td style="font-family: monospace;padding-right:12px;">const char *</td>
                <td>pointer to the string</td>
              </tr>
              <tr>
                <td style="font-family: monospace;padding-right:12px;">size_t</td>
                <td>number of bytes to write</td>
              </tr>
            </tbody>
          </table>
        </td>
      </tr>
      <tr>
        <td style="padding-top:.5em;font-weight:bold;">Return value</td>
      </tr>
      <tr>
        <td style="padding-left:1em;">The number of bytes of the pointed string written on the file descriptor.</td>
      </tr>
    </tbody>
  </table>
</div>

<p>The number that appears on the top right corner is the code associated to the system call (compare this with line 6 above), and by convention this goes into the <code class="highlighter-rouge">rax</code> register (see line 24). Since <code class="highlighter-rouge">sys_write</code> requires 3 integer parameters we only need the registers <code class="highlighter-rouge">rdi</code>, <code class="highlighter-rouge">rsi</code> and <code class="highlighter-rouge">rdx</code>, in this order. Therefore, the file descriptor, the standard output in this case, will go in <code class="highlighter-rouge">rdi</code>, the address of the first byte of the string will go in <code class="highlighter-rouge">rsi</code> while its length will be loaded into <code class="highlighter-rouge">rdx</code> (lines 25 to 27).</p>

<p>In order to make the actual system call we can now use the new opcode <code class="highlighter-rouge">syscall</code>. The return value, namely the number of bytes written by <code class="highlighter-rouge">sys_write</code> in this case, is returned in the <code class="highlighter-rouge">rax</code> register. With line 29 we save the return value in the stack in order to use it as an exit code to be passed to <code class="highlighter-rouge">sys_exit</code>.</p>

<p>Since the application has done everything that needed to be done, i.e. print a string to standard output, we are ready to terminate the execution of the main process. This is achieved by making the exit system call, whose “signature” is the following.</p>

<div style="background-color: #202000;padding:24px;margin:12px;font-size:80%;">
  <table>
    <tbody>
      <tr>
        <th>60. SYS_EXIT</th>
      </tr>
      <tr>
        <td style="padding-top:.5em;font-weight:bold;">Parameters</td>
      </tr>
      <tr>
        <td>
          <table style="padding-left:1em;">
            <tbody>
              <tr>
                <td style="font-family: monospace;padding-right:12px;">int</td>
                <td>error code</td>
              </tr>
            </tbody>
          </table>
        </td>
      </tr>
      <tr>
        <td style="padding-top:.5em;font-weight:bold;">Return value</td>
      </tr>
      <tr>
        <td style="padding-left:1em;">This system call does not return.</td>
      </tr>
    </tbody>
  </table>
</div>

<p>With line 32 we load the code of <code class="highlighter-rouge">sys_exit</code> into the <code class="highlighter-rouge">rax</code> register in preparation for the system call. As error code, we might want to return <code class="highlighter-rouge">0</code> if <code class="highlighter-rouge">sys_write</code> has done its job properly, i.e. if it has written all the expected number of bytes, and something else otherwise. The simplest way to achieve this is by subtracting the string length from the return value of <code class="highlighter-rouge">sys_write</code>. Remember that we stored the latter in the stack, so it is now time to retrieve it. The first and only argument of <code class="highlighter-rouge">sys_exit</code> must go in <code class="highlighter-rouge">rdi</code>, so we might as well pop the <code class="highlighter-rouge">sys_write</code> return value in there directly, and this is precisely what line 33 does. On line 34 we subtract the length of the string from <code class="highlighter-rouge">rdi</code>, so that if <code class="highlighter-rouge">sys_write</code> has written all the expected number of bytes, <code class="highlighter-rouge">rdi</code> will now be <code class="highlighter-rouge">0</code>. The last instruction on line 35 is the <code class="highlighter-rouge">syscall</code> opcode that will make the system call and terminate the execution.</p>

<p>All right, time now to assemble, link and execute the above code.</p>

<div class="terminal"><div class="terminal-body flex-container flex-row">
<div class="pad-right"><pre>$ 
$ </pre></div>
<div><pre>
nasm -f elf64 -o hello64.o hello64.asm
ld -o hello64 hello64.o -I/lib64/ld-linux-x86-64.so.2
</pre></div>
</div></div>

<p>This will assemble the source code of <code class="highlighter-rouge">hello64.asm</code> into the object file <code class="highlighter-rouge">hello64.o</code>, while the linker will finish off the job by linking the interpreter to the object file and produce the ELF64 executable. To run the application, simply type</p>

<div class="terminal"><div class="terminal-body flex-container flex-row">
<div class="pad-right"><pre>$ </pre></div>
<div><pre>
./hello64
</pre></div>
</div></div>

<p>If you also want to display the exit code to make sure the executable is behaving as expected we could use</p>

<div class="terminal"><div class="terminal-body flex-container flex-row">
<div class="pad-right"><pre>$ </pre></div>
<div><pre>
./hello64; echo "exit code:" $?
</pre></div>
</div></div>

<p>and, on screen, we should now see</p>

<div class="terminal"><div class="terminal-body flex-container flex-row"><div><pre>
Hello World!
exit code: 0
</pre></div></div></div>

<p>Apart from the fun, another reason to write assembly code is that you can shrink the size of the executable file. Let’s check how big <code class="highlighter-rouge">hello64</code> is at this stage</p>

<div class="terminal"><div class="terminal-body flex-container flex-row"><div><pre>
$ wc -c &lt; hello64
1048
</pre></div></div></div>

<p>A kilobyte seems a bit excessive for an assembly application that only prints a short string on screen. The reason of such a bloated executable is in the symbol table created by NASM. This plays an important role inside our ELF file in case we’d need to link it with other object files. You can see all the symbols stored in the elf file with</p>

<div class="terminal"><div class="terminal-body flex-container flex-row"><div><pre>
$ objdump -t hello64

hello64:     file format elf64-x86-64

SYMBOL TABLE:
00000000004000b0 l    d  .text 0000000000000000 .text
00000000006000d8 l    d  .data 0000000000000000 .data
0000000000000000 l    df *ABS* 0000000000000000 hello64.asm
0000000000000001 l       *ABS* 0000000000000000 SYS_WRITE
000000000000003c l       *ABS* 0000000000000000 SYS_EXIT
0000000000000001 l       *ABS* 0000000000000000 STDOUT
00000000006000d8 l       .data 0000000000000000 hello
000000000000000d l       *ABS* 0000000000000000 hello_len
00000000004000b0 g       .text 0000000000000000 _start
00000000006000e5 g       .data 0000000000000000 __bss_start
00000000006000e5 g       .data 0000000000000000 _edata
00000000006000e8 g       .data 0000000000000000 _end
</pre></div></div></div>

<p>Assuming that we are not planning of doing this with our simple Hello World example, we strip the symbol table off <code class="highlighter-rouge">hello64</code> with</p>

<div class="terminal"><div class="terminal-body flex-container flex-row">
<div class="pad-right"><pre>$ </pre></div>
<div><pre>
strip -s hello64
</pre></div>
</div></div>

<p>If we now check the file size again, this is what we get</p>

<div class="terminal"><div class="terminal-body flex-container flex-row"><div><pre>
$ wc -c &lt; hello64
512
</pre></div></div></div>

<p>i.e. less than half the original size. Looking at the symbol table again, this is what we get now:</p>

<div class="terminal"><div class="terminal-body flex-container flex-row"><div><pre>
$ objdump -t hello64

hello64: file format elf64-x86-64

SYMBOL TABLE:
no symbols
</pre></div></div></div>

<p>Observe that we can obtain the same result with the -s switch to the linker we decide to use, that is, either ld or gcc. Thus, for example,</p>

<div class="terminal"><div class="terminal-body flex-container flex-row">
<div class="pad-right"><pre>$ </pre></div>
<div><pre>
ld -s -o hello64 hello64.o
</pre></div>
</div></div>

<p>will produce an ELF executable that lacks the symbol table completely.</p>

<p>The possibility of removing symbols from an ELF file gives us the chance of defining the constants for the system calls once and for all. In my GitHub repository you can find the file <a href="https://github.com/P403n1x87/asm/blob/master/syscalls/syscalls.inc"><code class="highlighter-rouge">syscalls.inc</code></a> where I have defined all the system calls together with their associated ID, and the “signature” of each on a comment line. With the help of this file, our source code would look like this</p>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td>
<td class="code"><pre><span class="kr">global</span> <span class="n">_start</span>

<span class="cp">%include</span> <span class="s">"../syscalls.inc"</span>

<span class="c">;</span>
<span class="c">; CONSTANTS</span>
<span class="c">;</span>
<span class="n">STDOUT</span>      <span class="k">equ</span> <span class="mi">1</span>

<span class="c">;</span>
<span class="c">; Initialised data goes here</span>
<span class="c">;</span>
<span class="kr">SECTION</span> <span class="p">.</span><span class="n">data</span>
<span class="n">hello</span>           <span class="kt">db</span>  <span class="s">"Hello World!"</span><span class="p">,</span> <span class="mi">10</span>      <span class="c">; char *</span>
<span class="n">hello_len</span>       <span class="k">equ</span> <span class="err">$</span><span class="o">-</span><span class="n">hello</span>                 <span class="c">; size_t</span>

<span class="c">;</span>
<span class="c">; Code goes here</span>
<span class="c">;</span>
<span class="kr">SECTION</span> <span class="p">.</span><span class="n">text</span>

<span class="n">_start</span><span class="o">:</span>
    <span class="c">; syscall(SYS_WRITE, STDOUT, hello, hello_len);</span>
    <span class="k">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="n">SYS_WRITE</span>
    <span class="k">mov</span>     <span class="n">rdi</span><span class="p">,</span> <span class="n">STDOUT</span>
    <span class="k">lea</span>     <span class="n">rsi</span><span class="p">,</span> <span class="p">[hello]</span>
    <span class="k">mov</span>     <span class="n">rdx</span><span class="p">,</span> <span class="n">hello_len</span>
    <span class="k">syscall</span>
    <span class="k">push</span>    <span class="n">rax</span>

    <span class="c">; syscall(SYS_EXIT, &lt;sys_write return value&gt; - hello_len);</span>
    <span class="k">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="n">SYS_EXIT</span>
    <span class="k">pop</span>     <span class="n">rdi</span>
    <span class="k">sub</span>     <span class="n">rdi</span><span class="p">,</span> <span class="n">hello_len</span>
    <span class="k">syscall</span></pre></td>
</tr></tbody></table></code></pre></figure>

<p class="caption">hello64_inc.asm</p>

<p>Note the inclusion of the file <code class="highlighter-rouge">syscalls.inc</code> at line 3, assumed to be stored in the parent folder of the one containing the assembly source code, and the only constant <code class="highlighter-rouge">STDOUT</code> at line 8.</p>

<p>If you do not need symbols in the final ELF file, you can just remove the symbol table completely with the previous command. However, if you want to retain some, but get rid of the one associated to constants that are meaningful to just your source code, you can add a <code class="highlighter-rouge">-N &lt;symbol name&gt;</code> (e.g. <code class="highlighter-rouge">strip -N STDOUT hello64</code>) switch to strip for each symbol you want dropped. To automate this when using <code class="highlighter-rouge">syscalls.inc</code>, one can execute the following (rather long) command</p>

<div class="terminal"><div class="terminal-body flex-container flex-row">
<div class="pad-right"><pre>$ </pre></div>
<div><pre>
strip `while IFS='' read -r line || [[ -n "$line" ]]; do read s _ &lt;&lt;&lt; $line; echo -n "-N $s "; done &lt; &lt;(tail -n +5 ../syscalls.inc)` hello64
</pre></div>
</div></div>

<p>on the ELF executable.</p>

<p>Finally, let’s verify that all we really have is pure assembly code, i.e. that our application doesn’t depend on external shared objects:</p>

<div class="terminal"><div class="terminal-body flex-container flex-row"><div><pre>
$ ldd hello64
        not a dynamic executable
</pre></div></div></div>

<p>In this case, this output is telling us that <code class="highlighter-rouge">hello64</code> is not linked to any other shared object files.</p>

<h1 id="hello-libc">
<a id="hello-libc" class="anchor" href="#hello-libc" aria-hidden="true"><span class="octicon octicon-link"></span></a>Hello libc!</h1>

<p>We shall now rewrite the above Hello World! example and let the Standard C Library take care of the output operation. That is, we won’t deal with system calls directly, we shall instead delegate a higher abstraction layer, the Standard C Library, do that for us. Furthermore, with this approach, we will also delegate some basic clean-up involving, e.g., open file descriptor, child processes etc…, which we would have to deal with otherwise. For a simple application like a Hello World! this last point is pretty much immaterial, but we will see in another post on GUIs with Gtk+ 3 the importance of waiting for child processes to terminate an application gracefully.</p>

<p>So the code we want to write is the assembly analogue of the following C code</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">printf</span><span class="p">(</span><span class="s">"Hello World!</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span> <span class="o">-</span> <span class="mi">13</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Inside the <code class="highlighter-rouge">main</code> function, we call <code class="highlighter-rouge">printf</code> to print the string on screen and then use its return value, decreased by the string length, as exit code. Thus, if <code class="highlighter-rouge">printf</code> writes all the bytes of our string, we get 0 as exit code, meaning that the call has been successful.</p>

<p>The didactic importance of this example resides in the use of the variadic function <code class="highlighter-rouge">printf</code>. The System V ABI specifies that, when calling a variadic function, the register <code class="highlighter-rouge">rax</code> should hold the number of XMM registers used for parameter passing. In this case, since we are just printing a string, we are not passing any other arguments apart from the location of the first character of the string, and therefore we need to set <code class="highlighter-rouge">rax</code> to zero. With all these considerations, the assembly analogue of the above C code will look like this</p>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td>
<td class="code"><pre><span class="kr">global</span> <span class="n">main</span>

<span class="kr">extern</span> <span class="n">printf</span>

<span class="c">;</span>
<span class="c">; Initialised data goes here</span>
<span class="c">;</span>
<span class="kr">SECTION</span> <span class="p">.</span><span class="n">data</span>
<span class="n">hello</span>           <span class="kt">db</span>  <span class="s">"Hello World!"</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">0</span>   <span class="c">; const char *</span>
<span class="n">hello_len</span>       <span class="k">equ</span> <span class="err">$</span> <span class="o">-</span> <span class="n">hello</span>               <span class="c">; size_t</span>
<span class="c">;</span>
<span class="c">; Code goes here</span>
<span class="c">;</span>
<span class="kr">SECTION</span> <span class="p">.</span><span class="n">text</span>

<span class="c">; int main ()</span>
<span class="n">main</span><span class="o">:</span>
    <span class="c">; return printf(hello) - hello_len;</span>
    <span class="k">lea</span>     <span class="n">rdi</span><span class="p">,</span> <span class="p">[hello]</span>
    <span class="k">xor</span>     <span class="n">rax</span><span class="p">,</span> <span class="n">rax</span>
    <span class="k">call</span>    <span class="n">printf</span>
    <span class="k">sub</span>     <span class="n">rax</span><span class="p">,</span> <span class="n">hello_len</span></pre></td>
</tr></tbody></table></code></pre></figure>

<p class="caption">hello64_libc.asm</p>

<p>On line 1 we export the main symbol, which will get called by the <code class="highlighter-rouge">libc</code> framework. On line 3 we instruct NASM that our application uses an external symbol, i.e. the variadic function <code class="highlighter-rouge">printf</code>. There is nothing new to say about the <code class="highlighter-rouge">.data</code> section, that starts at line 8. The code, however, is quite different. On line 17 we declare the label <code class="highlighter-rouge">main</code>, which marks the entry point of the C main function. We do not need local variables no access the standard argument of <code class="highlighter-rouge">main</code>, namely <code class="highlighter-rouge">argc</code> and <code class="highlighter-rouge">argv</code>, so we do not create a local stack frame. Instead, we go straight to calling <code class="highlighter-rouge">printf</code>. We load the string address in the <code class="highlighter-rouge">rdi</code> register (line 19), set the <code class="highlighter-rouge">rax</code> register to zero (line 20), since we are not passing any arguments by the XMM registers, and finally call the <code class="highlighter-rouge">printf</code> function. On the last line we subtract the string length, <code class="highlighter-rouge">hello_len</code>, from the return value of <code class="highlighter-rouge">printf</code>.</p>

<p>Assuming the above code resides in the file <code class="highlighter-rouge">hello64_libc.asm</code>, we can assemble and link it with</p>

<div class="terminal"><div class="terminal-body flex-container flex-row">
<div class="pad-right"><pre>$ 
$ </pre></div>
<div><pre>
nasm -f elf64 -o hello64_libc.o hello64_libc
gcc -o hello64_libc hello64_libc.o
</pre></div>
</div></div>

<p>The ELF executable I get on my machine is 8696 bytes in size, and 6328 without the symbol table. If we thought 1048 was too much for a simple Hello World application, the libc example is 8 times bigger. And without symbols, you can see that we are wasting about 8K by relying on the Standard C Library.</p>

<p>A somewhat intermediate approach is to drop the main function and only use the <code class="highlighter-rouge">printf</code> function from <code class="highlighter-rouge">libc</code>. The advantage is a reduced file size, since our executable only depends on the Standard C Library. However, as discussed above, we lose an important clean-up process that can be convenient, if not necessary, at times.</p>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td>
<td class="code"><pre><span class="kr">global</span> <span class="n">_start</span>

<span class="cp">%include</span> <span class="s">"../syscalls.inc"</span>

<span class="kr">extern</span> <span class="n">printf</span>

<span class="c">;</span>
<span class="c">; Initialised data goes here</span>
<span class="c">;</span>
<span class="kr">SECTION</span> <span class="p">.</span><span class="n">data</span>
<span class="n">hello</span>           <span class="kt">db</span>  <span class="s">"Hello World!"</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">0</span>   <span class="c">; const char *</span>
<span class="n">hello_len</span>       <span class="k">equ</span> <span class="err">$</span> <span class="o">-</span> <span class="n">hello</span> <span class="o">-</span> <span class="mi">1</span>           <span class="c">; size_t</span>
<span class="c">;</span>
<span class="c">; Code goes here</span>
<span class="c">;</span>
<span class="kr">SECTION</span> <span class="p">.</span><span class="n">text</span>

<span class="n">_start</span><span class="o">:</span>
    <span class="c">; printf(hello) - hello_len;</span>
    <span class="k">lea</span>     <span class="n">rdi</span><span class="p">,</span> <span class="p">[hello]</span>
    <span class="k">xor</span>     <span class="n">rax</span><span class="p">,</span> <span class="n">rax</span>
    <span class="k">call</span>    <span class="n">printf</span>
    <span class="k">sub</span>     <span class="n">rax</span><span class="p">,</span> <span class="n">hello_len</span>

    <span class="c">; syscall(SYS_EXIT, rax - hello_len)</span>
    <span class="k">push</span>    <span class="n">rax</span>
    <span class="k">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="n">SYS_EXIT</span>
    <span class="k">pop</span>     <span class="n">rdi</span>
    <span class="k">syscall</span></pre></td>
</tr></tbody></table></code></pre></figure>

<p class="caption">hello64_libc2.asm</p>

<p>Note how, on lines 1 and 18, we removed the main function and reintroduced the <code class="highlighter-rouge">_start</code> symbol to tell NASM where the entry point is. Thus, execution of our application now starts at line 20. Here we prepare to call the <code class="highlighter-rouge">printf</code> function from <code class="highlighter-rouge">libc</code> (lines 20 to 22), we compute the exit code (line 23) and we store it in the stack. Now there is no Standard C Library framework to terminate the execution for us, since we cannot return from the non-existent main function, and therefore we have to make a call to <code class="highlighter-rouge">SYS_EXIT</code> ourselves (lines 26 to 29).</p>

<p>Assuming this code resides in the file <code class="highlighter-rouge">hello64_libc2</code>, we assemble and link with the commands</p>

<div class="terminal"><div class="terminal-body flex-container flex-row">
<div class="pad-right"><pre>$ 
$ </pre></div>
<div><pre>
nasm -f elf64 -o hello64_libc2.o hello64_libc2
ld -s -o hello64_libc2 hello64_libc.o -I/lib64/ld-linux-x86-64.so.2
</pre></div>
</div></div>

<p>Checking the file size, this is what I get on my machine now</p>

<div class="terminal"><div class="terminal-body flex-container flex-row"><div><pre>
$ wc -c &lt; hello64_libc2
2056
</pre></div></div></div>

<p>i.e. about a third of the “full” <code class="highlighter-rouge">libc</code> example above. There is something we can still do with <code class="highlighter-rouge">strip</code>, namely determine which sections are not needed. After linking with <code class="highlighter-rouge">ld</code>, the ELF I get has the following sections</p>

<div class="terminal"><div class="terminal-body flex-container flex-row"><div><pre>
$ readelf -S hello64_libc2 | grep [.]
  [ 1] .interp           PROGBITS         0000000000400158  00000158
  [ 2] .hash             HASH             0000000000400178  00000178
  [ 3] .dynsym           DYNSYM           0000000000400190  00000190
  [ 4] .dynstr           STRTAB           00000000004001c0  000001c0
  [ 5] .gnu.version      VERSYM           00000000004001de  000001de
  [ 6] .gnu.version_r    VERNEED          00000000004001e8  000001e8
  [ 7] .rela.plt         RELA             0000000000400208  00000208
  [ 8] .plt              PROGBITS         0000000000400220  00000220
  [ 9] .text             PROGBITS         0000000000400240  00000240
  [10] .eh_frame         PROGBITS         0000000000400260  00000260
  [11] .dynamic          DYNAMIC          0000000000600260  00000260
  [12] .got.plt          PROGBITS         00000000006003a0  000003a0
  [13] .data             PROGBITS         00000000006003c0  000003c0
  [14] .shstrtab         STRTAB           0000000000000000  000003ce
</pre></div></div></div>

<p>By trials and errors, I have discovered that I can get rid of <code class="highlighter-rouge">.hash</code>, <code class="highlighter-rouge">.gnu.version</code> and <code class="highlighter-rouge">.eh_frame</code> while still getting a valid ELF executable that does its job. To get rid of these sections one can use the command</p>

<div class="terminal"><div class="terminal-body flex-container flex-row">
<div class="pad-right"><pre>$ </pre></div>
<div><pre>
strip -R .hash -R .gnu.version -R .eh_frame hello64_libc2
</pre></div>
</div></div>

<p>which yields an executable of 1832 bytes.</p>

<h1 id="conclusions">
<a id="conclusions" class="anchor" href="#conclusions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Conclusions</h1>

<p>With the above examples, we have seen that, if our real goal is that of coding a Hello World application meant to run on an architecture with the x86_64 instruction set, assembly is the best shot we have. Chances are, if you are coding an application, it is more complex than just printing a string on screen. Even pretending for a moment that you don’t care about the portability of your code, there are certainly some benefits from linking your application with gcc and letting the Standard C Library do some clean-up work for you. We will have the chance to see this last point from a close-up perspective in a future post. So take this current post as a reference point where you can look back when you need to recall the basics of writing a 64-bit assembly application for the Linux OS.</p>

    </div>

    <div class="comments">
  <h1>Comments</h1>

  
    
    
    <ul class="comment-list">
      
        
        
      
    </ul>
  

  <h2 id="comment-hdr">Leave a comment</h2>
  <script src="https://p403n1x87.github.io//js/comments.js"></script>

<form id     = "post-comment"
      class  = "comment"
      method = "post"
      action = "">

  <input type        = "text"
         name        = "fields[name]"
         id          = "name"
         placeholder = "Name"/>

  <input type        = "text"
         name        = "fields[email]"
         placeholder = "E-mail address (optional; stored hashed for privacy)"/>

  <textarea name        = "fields[comment]"
            id          = "comment"
            rows        = "5"
            placeholder = "Write your comment here. You can use markdown and LaTeX (use $...$ to inline)"></textarea>

  <button type  = "button"
          class = "flat_button"
          id    = "btn-submit-comment"
          onClick="submitComment();">
    SUBMIT FOR APPROVAL
  </button>


  <!-- Hidden fields -->

   <input type  = "hidden"
          name  = "fields[pic]"
          value = "x86_64-asm-101"/>

    <input type  = "hidden"
           id    = "timestamp"
           name  = "fields[timestamp]"
           value = "1557091936"/>

    <input type  = "hidden"
           id    = "parent"
           name  = "fields[parent]"
           value = "0"/>

</form>

<div id="snackbar"></div>


</div>

  </div>
</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The Hub of Heliopolis</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>The Hub of Heliopolis is maintained by Gabriele N. Tornetta</li>
          <li><a href="mailto:phoenix1987@gmail.com">phoenix1987@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <i class="fa fa-github" aria-hidden="true"></i>&nbsp;<a href="https://github.com/P403n1x87"><span class="username">P403n1x87</span></a>

          </li>
          

          

          <li>
            <i class="fa fa-rss-square" aria-hidden="true"></i>&nbsp;<a href="/feed.xml">Subscribe</a>
          </li>
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The Hub of Heliopolis is the <i>tech bay</i> of <a href="http://thenestofheliopolis.blogspot.co.uk/">The Nest of Heliopolis</a>. It is the home of all my <i>encounters</i> with technology that I consider worth sharing with the World.
</p>
      </div>
    </div>

    <div class="footer-copyright">
      Copyright (C) 2017 Gabriele N. Tornetta. All rights reserved.
    </div>

  </div>

</footer>


    
      <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-104560783-1', 'auto');
  ga('send', 'pageview');

</script>

    

    <script src="https://use.fontawesome.com/8c7b940d60.js"></script>

    <!-- MathJax support -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>


  </body>

</html>
